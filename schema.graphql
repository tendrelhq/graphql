schema {
  query: Query
  mutation: Mutation
}

"""
Indicates that a position is semantically non null: it is only null if there is a matching error in the `errors` array.
In all other cases, the position is non-null.

Tools doing code generation may use this information to generate the position as non-null if field errors are handled out of band:

```graphql
type User {
    # email is semantically non-null and can be generated as non-null by error-handling clients.
    email: String @semanticNonNull
}
```

The `levels` argument indicates what levels are semantically non null in case of lists:

```graphql
type User {
    # friends is semantically non null
    friends: [User] @semanticNonNull # same as @semanticNonNull(levels: [0])

    # every friends[k] is semantically non null
    friends: [User] @semanticNonNull(levels: [1])

    # friends as well as every friends[k] is semantically non null
    friends: [User] @semanticNonNull(levels: [0, 1])
}
```

`levels` are zero indexed.
Passing a negative level or a level greater than the list dimension is an error.
"""
directive @semanticNonNull(levels: [Int] = [0]) on FIELD_DEFINITION

input AcceptInvitationInput {
  authenticationIdentityId: ID!
  workerId: ID!
}

"""
Identifies an entity as being either "active" or "inactive".
Activatable entities have two operations: activate and deactivate.
"""
interface Activatable implements Component {
  active: Active @semanticNonNull
  id: ID!
}

type ActivationStatus {
  activatedAt: String
  active: Boolean!
  deactivatedAt: String
}

"""
TODO
"""
type Active {
  active: Boolean!
  updatedAt: Temporal @semanticNonNull
}

"""
TODO
"""
input ActiveInput {
  active: Boolean!
  updatedAt: TemporalInput
}

enum ApplicationType {
  Checklist
}

"""
Identifies an entity being assignable to another entity.
Assignable entities have two operations: assign and unassign.
"""
interface Assignable implements Component {
  id: ID!
}

type AssignableConnection {
  edges: [AssignableEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type AssignableEdge {
  cursor: String!
  node: Assignable!
}

"""
TODO
"""
type Assignee implements Component {
  assignedAt: Temporal!
  assignedTo: Assignable!
  id: ID!
}

type AssigneeConnection {
  edges: [AssigneeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type AssigneeEdge {
  cursor: String!
  node: Assignee!
}

"""
TODO
"""
input AssigneeInput {
  assignAt: TemporalInput!
  assignTo: ID!
  id: ID!
}

type AssignmentPayload {
  assignedTo: Assignable! @deprecated
  assignee: AssigneeEdge!
  entity: Assignable!
}

"""
TODO
"""
type Attachment implements Component & Node {
  attachedBy: Identity
  attachedOn: Temporal @semanticNonNull
  attachment: URL!
  id: ID!
}

type AttachmentConnection {
  edges: [AttachmentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type AttachmentEdge {
  cursor: String!
  node: Attachment!
}

"""
TODO
"""
type Auditable implements Component {
  auditable: Boolean!
  id: ID!
}

"""
TODO
"""
input AuditableInput {
  enabled: Boolean!
  id: ID!
}

type AuthenticationStatus {
  canLogin: Boolean!
  invitation: Invitation
}

type BooleanWidget implements Component {
  checked: Boolean
  id: ID!
}

"""
TODO
"""
input BooleanWidgetInput {
  value: Boolean
}

"""
TODO
"""
enum CalendarNameOptions {
  """
  TODO
  """
  always
  """
  TODO
  """
  auto
  """
  TODO
  """
  critical
  """
  TODO
  """
  never
}

"""
TODO
"""
type CheckboxWidget implements Component {
  checked: Boolean
  id: ID!
}

"""
TODO
"""
input CheckboxWidgetInput {
  value: Boolean
}

type Checklist implements Activatable & Assignable & Component & Node {
  active: Active @semanticNonNull
  assignees(
    after: String
    before: String
    first: Int
    last: Int
  ): AssigneeConnection!
  attachments(
    after: String
    before: String
    first: Int
    last: Int
  ): AttachmentConnection!
  auditable: Auditable
  chain: ChecklistChain
  children(
    after: String
    before: String
    first: Int
    last: Int
    search: ChecklistSearchOptions
  ): ChecklistConnection!
  description: Description
  id: ID!
  items(
    after: String
    before: String
    first: Int
    last: Int
    withActive: Boolean
  ): ChecklistItemConnection!
  metadata: Metadata!
  name: DisplayName!
  parent: Checklist
    @deprecated(
      reason: "Use Checklist.chain to inspect the chain, if that is what you are after. In the future, this will return a *Node* representing ownership."
    )
  required: Boolean
  schedule: Schedule
  sop: Sop
  status: ChecklistStatus
}

type ChecklistAggregate {
  assignedTo(assignees: [ID!]!, parent: ID!): Int @semanticNonNull
  dueOn(input: TemporalRangeInput!, parent: ID!): Int @semanticNonNull
}

type ChecklistChain {
  prev: Checklist
  root: Checklist
}

type ChecklistClosed implements State {
  closedAt: Temporal!
  closedBecause: ChecklistClosedReason
  closedBy: Identity
  dueAt: Temporal
  inProgressAt: Temporal
  openedAt: Temporal!
  tag: String
}

input ChecklistClosedInput {
  at: TemporalInput!
  because: ChecklistClosedReasonInput
  by: ID
}

type ChecklistClosedReason {
  code: ChecklistClosedReasonCode!
  note: DynamicString
}

enum ChecklistClosedReasonCode {
  cancel
  error
  success
}

input ChecklistClosedReasonInput {
  code: ChecklistClosedReasonCode!
  note: DynamicStringInput
}

type ChecklistConnection {
  edges: [ChecklistEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ChecklistEdge {
  cursor: String!
  node: Checklist!
}

type ChecklistInProgress implements State {
  dueAt: Temporal
  inProgressAt: Temporal!
  inProgressBy: Identity
  openedAt: Temporal!
  tag: String
}

input ChecklistInProgressInput {
  at: TemporalInput!
  by: ID
}

input ChecklistInput {
  active: ActiveInput
  assignees: [AssigneeInput!]
  auditable: AuditableInput
  customerId: ID!
  description: DescriptionInput
  id: ID!
  items: [ChecklistItemInput!]
  name: DisplayNameInput!
  required: Boolean
  schedule: ScheduleInput
  sop: SopInput
  status: ChecklistStatusInput
}

union ChecklistItem = Checklist | ChecklistResult

type ChecklistItemConnection {
  edges: [ChecklistItemEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ChecklistItemEdge {
  cursor: String!
  node: ChecklistItem!
}

input ChecklistItemInput @oneOf {
  checklist: ChecklistInput
  result: ChecklistResultInput
}

type ChecklistOpen implements State {
  dueAt: Temporal
  openedAt: Temporal!
  openedBy: Identity
  tag: String
}

input ChecklistOpenInput {
  at: TemporalInput!
  by: ID
}

"""
TODO
"""
type ChecklistResult implements Activatable & Component & Node {
  active: Active @semanticNonNull
  assignees(
    after: String
    before: String
    first: Int
    last: Int
  ): AssigneeConnection!
  attachments(
    after: String
    before: String
    first: Int
    last: Int
  ): AttachmentConnection!
  auditable: Auditable
  id: ID!
  name: DisplayName!
  order: Int!
  parent: Checklist!
  required: Boolean
  status: ChecklistStatus
  widget: Widget!
}

"""
TODO
"""
input ChecklistResultInput {
  assignees: [AssigneeInput!]
  auditable: AuditableInput
  id: ID!
  name: DisplayNameInput!
  order: Int!
  required: Boolean
  status: ChecklistStatusInput
  widget: WidgetInput!
}

input ChecklistSearchOptions {
  active: Boolean
  displayName: String
  status: [ChecklistStatusStates!]
}

input ChecklistSortOrder @oneOf {
  name: SortOrder
  status: SortOrder
}

union ChecklistStatus = ChecklistClosed | ChecklistInProgress | ChecklistOpen

input ChecklistStatusInput @oneOf {
  closed: ChecklistClosedInput
  inProgress: ChecklistInProgressInput
  open: ChecklistOpenInput
}

enum ChecklistStatusStates {
  closed
  inProgress
  open
}

"""
TODO
"""
type ClickerWidget implements Component {
  id: ID!
  number: Int
}

"""
TODO
"""
input ClickerWidgetInput {
  value: Int
}

type Closed {
  closedAt: String @semanticNonNull
  closedBecause: String
  closedBy: String
  dueAt: String
  inProgressAt: String
  inProgressBy: String
  openedAt: String @semanticNonNull
  openedBy: String
}

"""
Components characterize Entities as possessing a particular trait.
They are just simple structs, holding all data necessary to model that trait.
"""
interface Component {
  id: ID!
}

type ComponentConnection {
  edges: [ComponentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ComponentEdge {
  cursor: String!
  debug: DebugInfo!
  node: Component!
}

input CopyFromOptions {
  withAssignee: [ID!]
  withStatus: ChecklistStatusStates
}

type CopyFromPayload {
  edge: ChecklistEdge!
}

"""
Data type for tracking an incrementable/decrementable integer value.
Counters have two operations: increment and decrement.
"""
type Counter {
  count: Int
}

input CreateInvitationInput {
  emailAddress: String!
  orgId: ID!
  redirectUrl: String
  workerId: ID!
}

input CreateLocationInput {
  active: Boolean!
  id: ID
  name: CreateNameInput!
  orgId: ID!
  scanCode: ID
}

input CreateNameInput {
  active: Boolean!
  id: ID
  languageId: ID!
  value: String!
}

input CreateUserInput {
  active: Boolean!
  displayName: String
  firstName: String!
  identityId: String!
  lastName: String!
  username: String
}

input CreateWorkerInput {
  active: Boolean!
  displayName: String
  firstName: String!
  id: ID
  languageId: ID!
  lastName: String!
  orgId: ID!
  roleId: ID!
  scanCode: ID
  userId: ID
}

"""
A string representing a cron schedule expression
"""
scalar CronExpression

"""
Schedule implementation using cron expressions
"""
type CronSchedule {
  cron: CronExpression!
}

type DebugInfo {
  createdAt: String!
  updatedAt: String!
  updatedBy: Identity
}

"""
TODO
"""
type Description implements Component {
  description: DynamicString!
  id: ID!
}

"""
TODO
"""
input DescriptionInput {
  id: ID!
  value: DynamicStringInput!
}

type DisplayName implements Component & Node {
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
  name: DynamicString @semanticNonNull
}

"""
TODO
"""
input DisplayNameInput {
  id: ID!
  value: DynamicStringInput!
}

"""
Duration represented in seconds
"""
scalar Duration

"""
TODO
"""
type DurationWidget implements Component {
  duration: Duration
  id: ID!
}

"""
TODO
"""
input DurationWidgetInput {
  value: Duration
}

"""
Plain text content that has been (potentially) translated into different
languages as specified by the user's configuration.
"""
type DynamicString {
  locale: Locale @semanticNonNull
  value: String @semanticNonNull
}

input DynamicStringInput {
  locale: Locale!
  value: String!
}

type EnabledLanguage implements Node {
  active: ActivationStatus!
  id: ID!
  language: Language!
  languageId: ID!
  primary: Boolean!
}

type EnabledLanguageConnection {
  edges: [EnabledLanguageEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type EnabledLanguageEdge {
  cursor: String!
  node: EnabledLanguage!
}

input EnabledLanguageSearchOptions {
  active: Boolean
  primary: Boolean
}

type EntityConnection {
  components(
    after: String
    before: String
    first: Int
    last: Int
  ): ComponentConnection!
  entity: ID!
}

"""
Data type for tracking Boolean-like values in the form of "enabled" or
"disabled".
Flags only support two operations: enable and disable.
"""
type Flag {
  enabled: Boolean
}

type Geofence {
  latitude: String!
  longitude: String!
  radius: Float!
}

input GeofenceInput {
  latitude: String
  longitude: String
  radius: Float
}

type Geography {
  geog: String
}

interface Identity implements Component {
  id: ID!
}

type InProgress {
  dueAt: String
  inProgressAt: String @semanticNonNull
  inProgressBy: String
  openedAt: String @semanticNonNull
  openedBy: String
}

"""
Fixed point in time (i.e. "exact time") without regard to calendar or location
"""
type Instant implements Temporal {
  """
  Milliseconds since the UNIX epoch of 1/1/1970 00:00+00
  """
  epochMilliseconds: String!
  """
  Convert an Instant to a ZonedDateTime
  """
  toZonedDateTime(timeZone: TimeZone!): ZonedDateTime @semanticNonNull
}

input InstantToStringOptions {
  """
  How many digits to print after the decimal point in the output string
  """
  fractionalSecondDigits: Int
  """
  How to handle the remainder
  """
  roundingMode: RoundingMode
  """
  The smallest unit of time to include in the output string
  """
  smallestUnit: SmallestTimeUnit
  """
  The time zone to express the Instant/ZonedDateTime in
  """
  timeZone: TimeZone
}

type Invitation {
  createdAt: String!
  emailAddress: String!
  id: ID!
  status: InvitationStatus!
  updatedAt: String!
  workerId: ID!
}

enum InvitationStatus {
  accepted
  expired
  pending
  revoked
}

type Language {
  code: String!
  id: ID!
  name: Name!
  nameId: ID!
}

"""
A language tag in the format of a BCP 47 (RFC 5646) standard string.
"""
scalar Locale @specifiedBy(url: "https://www.rfc-editor.org/rfc/rfc5646.html")

type Location implements Component & Node & Referenceable & Trackable {
  active: ActivationStatus!
  children(options: LocationsQueryOptions): [Location!]!
  geofence: Geofence
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
  name: Name!
  nameId: ID!
  parent: Location
  parentId: ID
  scanCode: ID
  site: Location!
  siteId: ID!
  tags: [Tag!]!
  timeZone: String!
  """
  Entrypoint into the "tracking system(s)" for the given Location.
  """
  tracking: TrackableConnection
}

type LocationConnection {
  edges: [LocationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type LocationEdge {
  cursor: String!
  node: Location!
}

input LocationSearchOptions {
  active: Boolean
  isSite: Boolean
}

input LocationsQueryOptions {
  cornerstone: Boolean
  site: Boolean
}

"""
Metadata pertaining to an individual Entity, e.g. when it was last updated and
by whom.
"""
type Metadata {
  updatedAt: Temporal!
  updatedBy: Identity
}

"""
TODO
"""
type MultilineStringWidget implements Component {
  id: ID!
  string: String
}

"""
TODO
"""
input MultilineStringWidgetInput {
  value: String
}

type Mutation {
  acceptInvitation(input: AcceptInvitationInput!): Worker!
  """
  Activate an entity with the Activatable component. If the entity is already
  active, this operation is a no-op. Throws an error with code E_NOT_ACTIVATABLE
  if the entity being activated is not, in fact, Activatable.
  """
  activate(entity: ID!): Activatable!
  activateWorker(id: ID!): Worker!
  """
  Assign an entity to another entity. If the entity is already assigned to the
  same entity, this operation is a no-op.

  Errors:
  - E_NOT_ASSIGNABLE, if either entity is not assignable
  - E_ASSIGN_CONFLICT, if the entity is assigned to a different entity
  """
  assign(entity: ID!, to: ID!): AssignmentPayload!
  attach(attachments: [URL!]!, entity: ID!): [AttachmentEdge!]!
  copyFrom(entity: ID!, options: CopyFromOptions!): CopyFromPayload!
  createEntity(id: String, suffix: [String!], type: String!): ID!
  createInvitation(input: CreateInvitationInput!): Worker!
  createLocation(input: CreateLocationInput!): Location!
  createUser(input: CreateUserInput!): User!
  createWorker(input: CreateWorkerInput!): WorkerEdge!
  """
  Deactivate an entity with the Activatable component. If the entity is already
  inactive, this operation is a no-op. Throws an error with code
  E_NOT_ACTIVATABLE if the entity being deactivated is not, in fact, Activatable.
  """
  deactivate(entity: ID!): Activatable!
  deactivateWorker(id: ID!): Worker!
  disableLanguage(languageId: ID!, orgId: ID!): EnabledLanguageEdge!
  enableLanguage(languageId: ID!, orgId: ID!): EnabledLanguageEdge!
  saveChecklist(input: ChecklistInput!): ChecklistEdge!
  setStatus(
    entity: ID!
    input: ChecklistStatusInput!
    parent: ID
  ): SetStatusPayload!
  setValue(entity: ID!, input: WidgetInput!, parent: ID!): SetValuePayload!
  transition(input: TransitionInput!): TransitionResult @semanticNonNull
  """
  Unssign an entity from another entity. If the entity is already unassigned,
  this operation is a no-op.

  Errors:
  - E_NOT_ASSIGNABLE, if either entity is not (un)assignable
  - E_ASSIGN_CONFLICT, if the entity is assigned to a different entity
  """
  unassign(entity: ID!, from: ID!): UnassignmentPayload!
  updateLocation(input: UpdateLocationInput!): Location!
  updateName(input: UpdateNameInput!): Name!
  updateUser(input: UpdateUserInput!): User!
  updateWorker(input: UpdateWorkerInput!): WorkerEdge!
}

type Name implements Node {
  id: ID!
  language: Language!
  languageId: ID!
  metadata: NameMetadata!
  value: String!
}

type NameMetadata {
  nameId: ID!
  sourceLanguage: Language!
  sourceLanguageId: ID!
  sourceText: String!
  translatedAt: String!
}

"""
Indicates an object that is "refetchable".
"""
interface Node {
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
}

"""
TODO
"""
type NumberWidget implements Component {
  id: ID!
  number: Int
}

"""
TODO
"""
input NumberWidgetInput {
  value: Int
}

"""
TODO
"""
enum OffsetOptions {
  """
  TODO
  """
  auto
  """
  TODO
  """
  never
}

"""
Schedule implementation for "oneshot" events
"""
type OnceSchedule {
  once: Temporal!
}

type Open {
  dueAt: String
  openedAt: TimestampOverridable @semanticNonNull
  openedBy: String
}

type Organization implements Node {
  activatedAt: String
  active: Boolean!
  billingId: String
  deactivatedAt: String
  id: ID!
  languages(
    after: String
    before: String
    first: Int
    last: Int
    search: EnabledLanguageSearchOptions
  ): EnabledLanguageConnection!
  locations(
    after: String
    before: String
    first: Int
    last: Int
    search: LocationSearchOptions
  ): LocationConnection!
  me: Worker!
  name: Name!
  nameId: ID!
  workers(
    after: String
    before: String
    first: Int
    last: Int
    search: WorkerSearchOptions
  ): WorkerConnection!
}

type OrganizationConnection {
  edges: [OrganizationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type OrganizationEdge {
  node: Organization!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean @semanticNonNull
  hasPreviousPage: Boolean @semanticNonNull
  startCursor: String
}

type Query {
  """
  For the given Assignable `entity`, returns a connection representing the set
  of Assignable entities to which the given `entity` can be assigned.

  Errors:
  - E_NOT_ASSIGNABLE, if `entity` is not assignable
  """
  assignable(entity: ID!): AssignableConnection!
  checklistAgg: ChecklistAggregate!
  checklists(
    after: String
    before: String
    first: Int
    last: Int
    parent: ID!
    sortBy: [ChecklistSortOrder!]
    withActive: Boolean
    withAssignee: [ID!]
    withDueDate: TemporalRangeInput
    withName: String
    withStatus: [ChecklistStatusStates!]
  ): ChecklistConnection!
  entity(id: ID!): EntityConnection!
  languages: [Language!]!
  node(id: ID!): Node!
  roles: [Tag!]!
  """
  Query for Trackable entities in the given `parent` hierarchy.
  """
  trackables(
    """
    Identifies the root of the hierarchy in which to search for Trackable
    entities.

    Valid parent types are currently:
    - Customer

    All other parent types will be gracefully ignored.
    """
    parent: ID!
  ): TrackableConnection @semanticNonNull
  user: User!
}

"""
Data type for tracking references to other object.
"""
type Reference {
  ref: Referenceable
}

"""
TODO
"""
type ReferenceWidget implements Component {
  id: ID!
  possibleTypes: [String!]!
  ref: Referenceable
}

"""
TODO
"""
input ReferenceWidgetInput {
  possibleTypes: [String!]!
  value: ID
}

interface Referenceable implements Component {
  id: ID!
}

"""
Data type for tracking named binaries (like strings). Any binary value can act
as the value of a register. Registers can only have the binaries stored within
them changed.
"""
type Register {
  binary: String
}

type Requirement implements Component {
  id: ID!
  requires: ID!
}

"""
Controls how rounding is performed
"""
enum RoundingMode {
  """
  Always round up, towards the end of time
  """
  ceil
  """
  Always round down, towards the beginning of time
  """
  floor
}

"""
TODO
"""
union Schedule = CronSchedule | OnceSchedule

"""
TODO
"""
input ScheduleInput @oneOf {
  cron: String
  once: TemporalInput
}

"""
TODO
"""
enum ScheduleType {
  CronSchedule
  OnceSchedule
}

"""
TODO
"""
type SectionWidget implements Component {
  id: ID!
  title: String
}

"""
TODO
"""
input SectionWidgetInput {
  value: String
}

enum Sentiment {
  negative
  neutral
  positive
}

"""
TODO
"""
type SentimentWidget implements Component {
  id: ID!
  number: Int
}

"""
TODO
"""
input SentimentWidgetInput {
  value: Int
}

type SetChecklistItemStatusPayload implements SetStatusPayload {
  delta: Int!
  edge: ChecklistItemEdge!
  parent: Checklist!
}

type SetChecklistStatusPayload implements SetStatusPayload {
  delta: Int!
  edge: ChecklistEdge!
}

interface SetStatusPayload {
  delta: Int!
}

type SetValuePayload {
  delta: Int!
  node: ChecklistResult!
  parent: Checklist!
}

enum SmallestTimeUnit {
  millisecond
  minute
  second
}

"""
TODO
"""
type Sop implements Component {
  id: ID!
  sop: URL!
}

"""
TODO
"""
input SopInput {
  id: ID!
  link: URL!
}

"""
Defines the sort order for queries that support edge ordering.
Ordering depends on the scalar type:
  - Boolean scalars are sorted false < true
  - Int scalars are sorted numerically
  - String scalars are sorted lexicographically
"""
enum SortOrder {
  asc
  desc
}

"""
State characterizes something, most commonly an entity, as existing in a
particular state. For example, an entity could be in a "pending" state.
"""
interface State {
  tag: String
}

"""
TODO
"""
type StringWidget implements Component {
  id: ID!
  string: String
}

"""
TODO
"""
input StringWidgetInput {
  value: String
}

type Tag {
  id: ID!
  name: Name!
  nameId: ID!
  parent: Tag
  parentId: ID
  type: String!
}

"""
A system-level component that identifies an Entity as being applicable to
tendrel's internal "task processing pipeline". In practice, Tasks most often
represent "jobs" performed by humans. However, this need not always be the
case.

Technically speaking, a Task represents a (1) *named asynchronous process*
that (2) exists in one of three states: open, in progress, or closed.
"""
type Task implements Component & Node & Trackable {
  displayName: DisplayName @semanticNonNull
  """
  Tasks can have an associated StateMachine, which defines a finite set of
  states that the given Task can be in at any given time.
  """
  fsm: TaskStateMachine
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
  state: TaskState @semanticNonNull
  """
  Entrypoint into the "tracking system(s)" for the given Task.
  At the moment, sub-task tracking is not supported and therefore `null` will
  always be returned for this field.
  """
  tracking: TrackableConnection
}

type TaskConnection {
  edges: [TaskEdge!] @semanticNonNull
  pageInfo: PageInfo @semanticNonNull
  totalCount: Int @semanticNonNull
}

type TaskEdge {
  cursor: String @semanticNonNull
  node: Task @semanticNonNull
}

union TaskState = Closed | InProgress | Open

"""
Where applicable, Entities can have an associated StateMachine that defines
their current ("active") state in addition to possible next states that they
can "transition into". Typically, an end user does not need to be aware of
this state machine as Tendrel's internal engine maintains the machine and
associated states for a given Entity. However, in some cases it can be useful
to surface this information in userland such that a user can interact
directly with the underlying state machine.
"""
type TaskStateMachine {
  active: Task
  transitions: TaskConnection
}

interface Temporal {
  """
  Milliseconds since the UNIX epoch of 1/1/1970 00:00+00
  """
  epochMilliseconds: String!
}

input TemporalInput @oneOf {
  instant: String
  zdt: ZonedDateTimeInput
}

input TemporalRangeInput {
  after: TemporalInput
  before: TemporalInput
}

"""
TODO
"""
type TemporalWidget implements Component {
  id: ID!
  temporal: Temporal
}

"""
TODO
"""
input TemporalWidgetInput {
  value: TemporalInput
}

"""
A field whose value exists in the standard IANA Time Zone Database: https://www.iana.org/time-zones
"""
scalar TimeZone

"""
TODO
"""
enum TimeZoneNameOptions {
  """
  TODO
  """
  auto
  """
  TODO
  """
  critical
  """
  TODO
  """
  never
}

type Timestamp {
  value: String @semanticNonNull
}

type TimestampOverridable {
  override: TimestampOverride
  value: Timestamp @semanticNonNull
}

type TimestampOverride {
  overriddenAt: String @semanticNonNull
  overriddenBy: String @semanticNonNull
  previousValue: Timestamp @semanticNonNull
}

"""
Identifies an Entity as being "trackable".
What exactly this means depends on the type underlying said entity and is
entirely user defined.
"""
interface Trackable implements Component {
  id: ID!
  """
  Entrypoint into the "tracking system(s)" for a given Entity. Note that while
  many types admit to being trackable, this does not mean that all in fact are
  in practice. In order for an Entity to be trackable, it must be explicitly
  configured as such.
  """
  tracking: TrackableConnection
}

type TrackableConnection {
  edges: [TrackableEdge!] @semanticNonNull
  pageInfo: PageInfo @semanticNonNull
  totalCount: Int @semanticNonNull
}

type TrackableEdge {
  cursor: String @semanticNonNull
  node: Trackable @semanticNonNull
}

input TransitionInput {
  into: ID!
  payload: String
}

type TransitionResult {
  trackable: Trackable @semanticNonNull
}

"""
A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

type UnassignmentPayload {
  entity: Assignable!
  unassignedAssignees: [ID!]!
  unassignedFrom: Assignable! @deprecated
}

input UpdateLocationInput {
  activatedAt: String
  deactivatedAt: String
  geofence: GeofenceInput
  id: ID!
  name: UpdateNameInput
  scanCode: ID
}

input UpdateNameInput {
  activatedAt: String
  deactivatedAt: String
  id: ID!
  languageId: ID!
  value: String!
}

input UpdateUserInput {
  displayName: String
  firstName: String!
  id: ID!
  languageId: ID!
  lastName: String!
}

input UpdateWorkerInput {
  active: Boolean
  displayName: String
  firstName: String
  id: ID!
  languageId: ID
  lastName: String
  roleId: ID
  scanCode: ID
}

type User implements Node {
  activatedAt: String
  active: Boolean!
  authenticationIdentityId: ID
  authenticationProvider: Tag
  authenticationProviderId: ID
  deactivatedAt: String
  displayName: String!
  firstName: String!
  id: ID!
  language: Language!
  languageId: ID!
  lastName: String!
  organizations(
    after: String
    before: String
    first: Int
    last: Int
    withApp: [ApplicationType!]
  ): OrganizationConnection!
  tags: [Tag!]!
}

input UserSearchOptions {
  displayName: String
}

"""
TODO
"""
union Widget =
  | BooleanWidget
  | CheckboxWidget
  | ClickerWidget
  | DurationWidget
  | MultilineStringWidget
  | NumberWidget
  | ReferenceWidget
  | SectionWidget
  | SentimentWidget
  | StringWidget
  | TemporalWidget

"""
TODO
"""
input WidgetInput @oneOf {
  boolean: BooleanWidgetInput
  checkbox: CheckboxWidgetInput
  clicker: ClickerWidgetInput
  duration: DurationWidgetInput
  multiline: MultilineStringWidgetInput
  number: NumberWidgetInput
  reference: ReferenceWidgetInput
  section: SectionWidgetInput
  sentiment: SentimentWidgetInput
  string: StringWidgetInput
  temporal: TemporalWidgetInput
}

type Worker implements Assignable & Component & Identity & Referenceable {
  _hack_numeric_id: Int!
  active: ActivationStatus!
  auth: AuthenticationStatus!
  displayName: String!
  firstName: String!
  id: ID!
  language: Language!
  languageId: ID!
  lastName: String!
  organizationId: ID!
  role: Tag!
  roleId: ID!
  scanCode: String
  tags: [Tag!]!
  user: User!
  userId: ID!
}

type WorkerConnection {
  edges: [WorkerEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type WorkerEdge {
  cursor: String!
  node: Worker!
}

input WorkerSearchOptions {
  active: Boolean
  displayName: String
  user: UserSearchOptions @deprecated(reason: "use displayName instead")
}

input WorkersQueryOptions {
  active: Boolean
  site: ID
}

"""
Timezone-aware, calendar-aware date/time object representing an exact time
from the perspective of a particular geographic region
"""
type ZonedDateTime implements Temporal {
  day: Int @semanticNonNull
  """
  Milliseconds since the UNIX epoch of 1/1/1970 00:00+00
  """
  epochMilliseconds: String!
  hour: Int @semanticNonNull
  millisecond: Int @semanticNonNull
  minute: Int @semanticNonNull
  month: Int @semanticNonNull
  second: Int @semanticNonNull
  timeZone: TimeZone!
  """
  Convert a ZonedDateTime to an ISO 8601 string
  """
  toString(options: ZonedDateTimeToStringOptions): String @semanticNonNull
  year: Int @semanticNonNull
}

input ZonedDateTimeInput {
  epochMilliseconds: String!
  timeZone: TimeZone!
}

input ZonedDateTimeToStringOptions {
  calendarName: CalendarNameOptions
  """
  How many digits to print after the decimal point in the output string
  """
  fractionalSecondDigits: Int
  offset: OffsetOptions
  """
  How to handle the remainder
  """
  roundingMode: RoundingMode
  """
  The smallest unit of time to include in the output string
  """
  smallestUnit: SmallestTimeUnit
  timeZoneName: TimeZoneNameOptions
}
