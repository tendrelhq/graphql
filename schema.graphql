schema {
  query: Query
  mutation: Mutation
}

"""
Indicates that a position is semantically non null: it is only null if there is a matching error in the `errors` array.
In all other cases, the position is non-null.

Tools doing code generation may use this information to generate the position as non-null if field errors are handled out of band:

```graphql
type User {
    # email is semantically non-null and can be generated as non-null by error-handling clients.
    email: String @semanticNonNull
}
```

The `levels` argument indicates what levels are semantically non null in case of lists:

```graphql
type User {
    # friends is semantically non null
    friends: [User] @semanticNonNull # same as @semanticNonNull(levels: [0])

    # every friends[k] is semantically non null
    friends: [User] @semanticNonNull(levels: [1])

    # friends as well as every friends[k] is semantically non null
    friends: [User] @semanticNonNull(levels: [0, 1])
}
```

`levels` are zero indexed.
Passing a negative level or a level greater than the list dimension is an error.
"""
directive @semanticNonNull(levels: [Int] = [0]) on FIELD_DEFINITION

input AcceptInvitationInput {
  authenticationIdentityId: ID!
  workerId: ID!
}

"""
Identifies an entity as being either "active" or "inactive".
Activatable entities have two operations: activate and deactivate.
"""
interface Activatable implements Component {
  active: Active @semanticNonNull
  id: ID!
}

input ActivateNodeOperation {
  active: Boolean!
  node: ID!
}

type ActivationStatus {
  activatedAt: String
  active: Boolean!
  deactivatedAt: String
}

"""
TODO
"""
type Active {
  active: Boolean!
  updatedAt: Temporal @semanticNonNull
}

"""
TODO
"""
input ActiveInput {
  active: Boolean!
  updatedAt: TemporalInput
}

input AddFieldOperation {
  field: ID
  parent: ID!
  value: ValueInput
  valueType: ValueType!
}

input AdvanceFsmOptions {
  fsm: AdvanceTaskOptions!
  task: AdvanceTaskOptions!
}

input AdvanceTaskOperation {
  hash: String!
  task: ID!
}

input AdvanceTaskOptions {
  """
  This should be the Task's current hash (as far as you know) as it was
  returned to you when first querying for the Task in question.
  """
  hash: String!
  id: ID!
  overrides: [FieldInput!]
}

type AdvanceTaskStateMachineResult {
  diagnostics: [Diagnostic!]
  instantiations: [TaskEdge!] @semanticNonNull
  root: Task @semanticNonNull
}

type Aggregate {
  """
  The group, or bucket, that uniquely identifies this aggregate.
  For example, this will be one of the `overType`s passed to `chainAgg`.
  """
  group: String @semanticNonNull
  """
  The computed aggregate value.

  Currently, this will always be a string value representing a duration in
  seconds, e.g. "360" -> 360 seconds. `null` will be returned when no such
  aggregate can be computed, e.g. "time in planned downtime" when no "planned
  downtime" events exist. Note also that `null` will be returned if a
  duration cannot be computed, e.g. because there is no end date.
  """
  value: String
}

enum ApplicationType {
  Checklist
}

input AssignTaskOperation {
  assignTo: [ID!]
  task: ID!
  unassignFrom: [ID!]
}

"""
Identifies an Entity as being assignable to another Entity.
"""
interface Assignable implements Component {
  id: ID!
}

type AssignableConnection {
  edges: [AssignableEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type AssignableEdge {
  cursor: String!
  node: Assignable!
}

"""
TODO
"""
type Assignee implements Component {
  assignedAt: Temporal!
  assignedTo: Assignable!
  id: ID!
}

type AssigneeConnection {
  edges: [AssigneeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type AssigneeEdge {
  cursor: String!
  node: Assignee!
}

"""
TODO
"""
input AssigneeInput {
  assignAt: TemporalInput!
  assignTo: ID!
  id: ID!
}

"""
Encapsulates the "who" and "when" associated with the act of "assignment".
For example, both Tasks and Workers implement Assignable and therefore a Task
can be assigned to a Worker and vice versa ("assignment" is commutative). In
this example, the "who" will always be the Worker and the "when" will be the
timestamp when these two Entities were assigned.
"""
type Assignment implements Node {
  """
  NOT YET IMPLEMENTED - will always return null!
  """
  assignedAt: TimestampOverridable
  assignedTo: Assignable
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
}

type AssignmentConnection {
  edges: [AssignmentEdge!] @semanticNonNull
  pageInfo: PageInfo @semanticNonNull
  totalCount: Int @semanticNonNull
}

type AssignmentEdge {
  cursor: String @semanticNonNull
  node: Assignment @semanticNonNull
}

input AssignmentInput {
  assignedTo: ID!
}

type AssignmentPayload {
  assignedTo: Assignable! @deprecated
  assignee: AssigneeEdge!
  entity: Assignable!
}

type Attachment implements Component & Node {
  attachedBy: Identity
  attachedOn: Temporal @semanticNonNull
  """
  If you are using [Relay](https://relay.dev), make sure you annotate this
  field with `@catch(to: RESULT)` to avoid intermittent S3 errors from
  crashing the entire fragment.
  """
  attachment: URL @semanticNonNull
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
}

type AttachmentConnection {
  edges: [AttachmentEdge!] @semanticNonNull
  pageInfo: PageInfo @semanticNonNull
  totalCount: Int @semanticNonNull
}

type AttachmentEdge {
  cursor: String @semanticNonNull
  node: Attachment @semanticNonNull
}

"""
TODO
"""
type Auditable implements Component {
  auditable: Boolean!
  id: ID!
}

"""
TODO
"""
input AuditableInput {
  enabled: Boolean!
  id: ID!
}

type AuthenticationStatus {
  canLogin: Boolean!
  invitation: Invitation
}

type BooleanValue {
  boolean: Boolean
}

type BooleanWidget implements Component {
  checked: Boolean
  id: ID!
}

"""
TODO
"""
input BooleanWidgetInput {
  value: Boolean
}

"""
TODO
"""
enum CalendarNameOptions {
  """
  TODO
  """
  always
  """
  TODO
  """
  auto
  """
  TODO
  """
  critical
  """
  TODO
  """
  never
}

"""
TODO
"""
type CheckboxWidget implements Component {
  checked: Boolean
  id: ID!
}

"""
TODO
"""
input CheckboxWidgetInput {
  value: Boolean
}

type Checklist implements Activatable & Assignable & Component & Node {
  active: Active @semanticNonNull
  assignees(
    after: String
    before: String
    first: Int
    last: Int
  ): AssigneeConnection!
  attachments(
    after: String
    before: String
    first: Int
    last: Int
  ): AttachmentConnection!
  auditable: Auditable
  chain: ChecklistChain
  children(
    after: String
    before: String
    first: Int
    last: Int
    search: ChecklistSearchOptions
  ): ChecklistConnection!
  description: Description
  draft: Boolean
  id: ID!
  items(
    after: String
    before: String
    first: Int
    last: Int
    withActive: Boolean
    withDraft: Boolean
  ): ChecklistItemConnection!
  metadata: Metadata!
  name: DisplayName!
  parent: Checklist
    @deprecated(
      reason: "Use Checklist.chain to inspect the chain, if that is what you are after. In the future, this will return a *Node* representing ownership."
    )
  required: Boolean
  schedule: Schedule
  sop: Sop
  status: ChecklistStatus
}

type ChecklistAggregate {
  assignedTo(assignees: [ID!]!, parent: ID!): Int @semanticNonNull
  dueOn(input: TemporalRangeInput!, parent: ID!): Int @semanticNonNull
}

type ChecklistChain {
  prev: Checklist
  root: Checklist
}

type ChecklistClosed implements State {
  closedAt: Temporal!
  closedBecause: ChecklistClosedReason
  closedBy: Identity
  dueAt: Temporal
  inProgressAt: Temporal
  openedAt: Temporal!
  tag: String
}

input ChecklistClosedInput {
  at: TemporalInput!
  because: ChecklistClosedReasonInput
  by: ID
}

type ChecklistClosedReason {
  code: ChecklistClosedReasonCode!
  note: DynamicString
}

enum ChecklistClosedReasonCode {
  cancel
  error
  success
}

input ChecklistClosedReasonInput {
  code: ChecklistClosedReasonCode!
  note: DynamicStringInput
}

type ChecklistConnection {
  edges: [ChecklistEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ChecklistEdge {
  cursor: String!
  node: Checklist!
}

type ChecklistInProgress implements State {
  dueAt: Temporal
  inProgressAt: Temporal!
  inProgressBy: Identity
  openedAt: Temporal!
  tag: String
}

input ChecklistInProgressInput {
  at: TemporalInput!
  by: ID
}

input ChecklistInput {
  active: ActiveInput
  assignees: [AssigneeInput!]
  auditable: AuditableInput
  customerId: ID!
  description: DescriptionInput
  draft: Boolean
  id: ID!
  items: [ChecklistItemInput!]
  name: DisplayNameInput!
  required: Boolean
  schedule: ScheduleInput
  sop: SopInput
  status: ChecklistStatusInput
}

union ChecklistItem = Checklist | ChecklistResult

type ChecklistItemConnection {
  edges: [ChecklistItemEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ChecklistItemEdge {
  cursor: String!
  node: ChecklistItem!
}

input ChecklistItemInput @oneOf {
  checklist: ChecklistInput
  result: ChecklistResultInput
}

type ChecklistOpen implements State {
  dueAt: Temporal
  openedAt: Temporal!
  openedBy: Identity
  tag: String
}

input ChecklistOpenInput {
  at: TemporalInput!
  by: ID
}

"""
TODO
"""
type ChecklistResult implements Activatable & Component & Node {
  active: Active @semanticNonNull
  assignees(
    after: String
    before: String
    first: Int
    last: Int
  ): AssigneeConnection!
  attachments(
    after: String
    before: String
    first: Int
    last: Int
  ): AttachmentConnection!
  auditable: Auditable
  description: Description
  draft: Boolean
  id: ID!
  name: DisplayName!
  order: Int!
  parent: Checklist!
  required: Boolean
  status: ChecklistStatus
  widget: Widget!
}

"""
TODO
"""
input ChecklistResultInput {
  assignees: [AssigneeInput!]
  auditable: AuditableInput
  draft: Boolean
  id: ID!
  name: DisplayNameInput!
  order: Int!
  required: Boolean
  status: ChecklistStatusInput
  widget: WidgetInput!
}

input ChecklistSearchOptions {
  active: Boolean
  displayName: String
  status: [ChecklistStatusStates!]
}

input ChecklistSortOrder @oneOf {
  name: SortOrder
  status: SortOrder
}

union ChecklistStatus = ChecklistClosed | ChecklistInProgress | ChecklistOpen

input ChecklistStatusInput @oneOf {
  closed: ChecklistClosedInput
  inProgress: ChecklistInProgressInput
  open: ChecklistOpenInput
}

enum ChecklistStatusStates {
  closed
  inProgress
  open
}

"""
TODO
"""
type ClickerWidget implements Component {
  id: ID!
  number: Int
}

"""
TODO
"""
input ClickerWidgetInput {
  value: Int
}

type Closed {
  closedAt: TimestampOverridable @semanticNonNull
  closedBecause: String
  closedBy: Assignable
  inProgressAt: TimestampOverridable
  inProgressBy: Assignable
  openedAt: TimestampOverridable @semanticNonNull
  openedBy: Assignable
}

input ClosedInput {
  closedAt: Timestamp
  closedBecause: String
  closedBy: ID
  inProgressAt: Timestamp
  inProgressBy: ID
  openedAt: Timestamp
  openedBy: ID
}

"""
Components characterize Entities as possessing a particular trait.
They are just simple structs, holding all data necessary to model that trait.
"""
interface Component {
  id: ID!
}

type ComponentConnection {
  edges: [ComponentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ComponentEdge {
  cursor: String!
  debug: DebugInfo!
  node: Component!
}

input CopyFromOptions {
  withAssignee: [ID!]
  withStatus: ChecklistStatusStates
}

type CopyFromPayload {
  edge: ChecklistEdge!
}

"""
Data type for tracking an incrementable/decrementable integer value.
Counters have two operations: increment and decrement.
"""
type Counter {
  count: Int
}

input CreateInvitationInput {
  emailAddress: String!
  orgId: ID!
  redirectUrl: String
  workerId: ID!
}

input CreateLocationInput {
  category: String!
  name: String!
  parent: ID!
  scanCode: String
  timeZone: String!
}

input CreateNameInput {
  active: Boolean!
  id: ID
  languageId: ID!
  value: String!
}

type CreateTemplateConstraintResult {
  constraint: TemplateConstraint
  diagnostics: [Diagnostic!] @semanticNonNull
  instantiations: [TaskEdge!] @semanticNonNull
}

input CreateUserInput {
  active: Boolean!
  displayName: String
  firstName: String!
  identityId: String!
  lastName: String!
  username: String
}

input CreateWorkerInput {
  active: Boolean!
  displayName: String
  firstName: String!
  id: ID
  languageId: ID!
  lastName: String!
  orgId: ID!
  roleId: ID!
  scanCode: ID
  userId: ID
}

"""
A string representing a cron schedule expression
"""
scalar CronExpression

"""
Schedule implementation using cron expressions
"""
type CronSchedule {
  cron: CronExpression!
}

type DebugInfo {
  createdAt: String!
  updatedAt: String!
  updatedBy: Identity
}

input DeleteNodeOperation {
  node: ID!
}

type Description implements Component & Node {
  description: DynamicString
    @deprecated(reason: "Use Description.locale and/or Description.value.")
    @semanticNonNull
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
  locale: String @semanticNonNull
  value: String @semanticNonNull
}

input DescriptionInput {
  id: ID
  value: DynamicStringInput!
}

type Diagnostic {
  code: DiagnosticKind @semanticNonNull
  message: String
}

enum DiagnosticKind {
  candidate_change_discarded
  candidate_choice_unavailable
  """
  Indicates that an operation expected an instance type to be provided but
  received a template type.
  """
  expected_instance_got_template
  """
  Indicates that an operation expected a template type to be provided but
  received an instance type.
  """
  expected_template_got_instance
  feature_not_available
  """
  Some operations accept an optional hash. This is misleading. You should
  _always_ pass a hash for operations that accept them.
  """
  hash_is_required
  """
  Diagnostics of this kind indicates that the requested operation is no longer
  a valid operation due to a state change that has not yet been observed by
  the client. Typically this is due to data staleness but may also occur for
  the _loser_ of a race under concurrency.

  Hashes are opaque. Clients should not attempt to derive any meaning from them.
  """
  hash_mismatch_precludes_operation
  """
  Indicates that an operation received a type that it is not allowed to
  operate on.
  """
  invalid_type
  """
  When you operate on a StateMachine<T>, there must obviously be a state
  machine to operate *on*. This diagnostic is returned when no such state
  machine exists.
  """
  no_associated_fsm
}

type DisplayName implements Component & Node {
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
  locale: String @semanticNonNull
  name: DynamicString
    @deprecated(
      reason: "Use the DisplayName.value and/or DisplayName.locale instead."
    )
    @semanticNonNull
  value: String @semanticNonNull
}

"""
TODO
"""
input DisplayNameInput {
  id: ID!
  value: DynamicStringInput!
}

"""
Duration represented in seconds
"""
scalar Duration

"""
TODO
"""
type DurationWidget implements Component {
  duration: Duration
  id: ID!
}

"""
TODO
"""
input DurationWidgetInput {
  value: Duration
}

"""
Plain text content that has been (potentially) translated into different
languages as specified by the user's configuration.
"""
type DynamicString {
  locale: Locale @semanticNonNull
  value: String @semanticNonNull
}

input DynamicStringInput {
  locale: Locale!
  value: String!
}

type EnabledLanguage implements Node {
  active: ActivationStatus!
  id: ID!
  language: Language!
  languageId: ID!
  primary: Boolean!
}

type EnabledLanguageConnection {
  edges: [EnabledLanguageEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type EnabledLanguageEdge {
  cursor: String!
  node: EnabledLanguage!
}

input EnabledLanguageSearchOptions {
  active: Boolean
  primary: Boolean
}

type EntityConnection {
  components(
    after: String
    before: String
    first: Int
    last: Int
  ): ComponentConnection!
  entity: ID!
}

type EntityValue {
  entity: Component
}

type Field {
  """
  Field attachments.
  """
  attachments(
    after: String
    before: String
    first: Int
    last: Int
  ): AttachmentConnection @semanticNonNull
  """
  Description of a Field.
  """
  description: Description
  """
  Unique identifier for this Field.
  """
  id: ID @semanticNonNull
  """
  Display name for a Field.
  """
  name: DisplayName @semanticNonNull
  """
  The value for this Field, if any. This field will always be present (when
  requested) for the given Field so as to convey the underlying data type of
  the (raw data) value. The underlying (raw data) value can be `null`.
  """
  value: Value @semanticNonNull
  """
  The type of data underlying `value`. This is provided as a convenience when
  interacting with field-level edits through other apis.
  """
  valueType: ValueType @semanticNonNull
}

type FieldConnection {
  edges: [FieldEdge!] @semanticNonNull
  pageInfo: PageInfo @semanticNonNull
  totalCount: Int @semanticNonNull
}

type FieldEdge {
  cursor: String @semanticNonNull
  node: Field @semanticNonNull
}

input FieldInput {
  field: ID!
  value: ValueInput
  """
  Must match the type of the `value`, e.g.
  ```typescript
  if (field.valueType === "string") {
    assert(field.value === null || "string" in field.value);
  }
  ```
  """
  valueType: ValueType!
}

input FieldOperations @oneOf {
  add: AddFieldOperation
  field: NodeOperations
  set: SetFieldOperation
}

"""
Data type for tracking Boolean-like values in the form of "enabled" or
"disabled".
Flags only support two operations: enable and disable.
"""
type Flag {
  enabled: Boolean
}

type Geofence {
  latitude: String!
  longitude: String!
  radius: Float!
}

input GeofenceInput {
  latitude: String
  longitude: String
  radius: Float
}

type Geography {
  geog: String
}

interface Identity implements Component {
  id: ID!
}

type InProgress {
  inProgressAt: TimestampOverridable @semanticNonNull
  inProgressBy: Assignable
  openedAt: TimestampOverridable @semanticNonNull
  openedBy: String
}

input InProgressInput {
  inProgressAt: Timestamp
  inProgressBy: ID
  openedAt: Timestamp
  openedBy: ID
}

"""
Fixed point in time (i.e. "exact time") without regard to calendar or location
"""
type Instant implements Temporal {
  """
  Milliseconds since the UNIX epoch of 1/1/1970 00:00+00
  """
  epochMilliseconds: String!
  """
  Convert an Instant to a ZonedDateTime
  """
  toZonedDateTime(timeZone: TimeZone!): ZonedDateTime @semanticNonNull
}

input InstantToStringOptions {
  """
  How many digits to print after the decimal point in the output string
  """
  fractionalSecondDigits: Int
  """
  How to handle the remainder
  """
  roundingMode: RoundingMode
  """
  The smallest unit of time to include in the output string
  """
  smallestUnit: SmallestTimeUnit
  """
  The time zone to express the Instant/ZonedDateTime in
  """
  timeZone: TimeZone
}

input InstantiateOptions {
  fields: [FieldInput!]
}

input InstantiateTaskOperation {
  """
  Immediately assign the newly instantiated Task to the given identities.
  """
  assignees: [ID!]
  """
  Apply the given field overrides to the newly instantiated Task.
  """
  fields: [FieldInput!]
  """
  Instantiate the Task into the given TaskState.
  """
  state: TaskStateInput
  task: ID!
}

type Invitation {
  createdAt: String!
  emailAddress: String!
  id: ID!
  status: InvitationStatus!
  updatedAt: String!
  workerId: ID!
}

enum InvitationStatus {
  accepted
  expired
  pending
  revoked
}

type Language {
  code: String!
  id: ID!
  name: Name!
  nameId: ID!
}

"""
A language tag in the format of a BCP 47 (RFC 5646) standard string.
"""
scalar Locale @specifiedBy(url: "https://www.rfc-editor.org/rfc/rfc5646.html")

type Location implements Component & Node & Referenceable & Trackable {
  active: ActivationStatus!
  children(options: LocationsQueryOptions): [Location!]!
  geofence: Geofence
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
  name: Name!
  nameId: ID!
  parent: Location
  parentId: ID
  scanCode: ID
  site: Location!
  siteId: ID!
  tags: [Tag!]!
  """
  IANA time zone identifier for this Location.
  """
  timeZone: String! @semanticNonNull
  """
  Entrypoint into the "tracking system(s)" for the given Location.
  """
  tracking(
    after: ID
    first: Int
    withStatus: [TaskStateName!]
  ): TrackableConnection @semanticNonNull
}

type LocationConnection {
  edges: [LocationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type LocationEdge {
  cursor: String!
  node: Location!
}

input LocationSearchOptions {
  active: Boolean
  isSite: Boolean
}

input LocationsQueryOptions {
  cornerstone: Boolean
  site: Boolean
}

"""
Metadata pertaining to an individual Entity, e.g. when it was last updated and
by whom.
"""
type Metadata {
  updatedAt: Temporal!
  updatedBy: Identity
}

"""
TODO
"""
type MultilineStringWidget implements Component {
  id: ID!
  string: String
}

"""
TODO
"""
input MultilineStringWidgetInput {
  value: String
}

type Mutation {
  acceptInvitation(input: AcceptInvitationInput!): Worker!
  """
  Activate an entity with the Activatable component. If the entity is already
  active, this operation is a no-op. Throws an error with code E_NOT_ACTIVATABLE
  if the entity being activated is not, in fact, Activatable.
  """
  activate(entity: ID!): Activatable!
  activateWorker(id: ID!): Worker!
  advance(opts: AdvanceFsmOptions!): AdvanceTaskStateMachineResult
    @semanticNonNull
  applyFieldEdits(edits: [FieldInput!]!, entity: ID!): Task @semanticNonNull
  """
  Assign an entity to another entity. If the entity is already assigned to the
  same entity, this operation is a no-op.

  Errors:
  - E_NOT_ASSIGNABLE, if either entity is not assignable
  - E_ASSIGN_CONFLICT, if the entity is assigned to a different entity
  """
  assign(entity: ID!, to: ID!): AssignmentPayload!
  attach(attachments: [URL!]!, entity: ID!): [AttachmentEdge!] @semanticNonNull
  copyFrom(entity: ID!, options: CopyFromOptions!): CopyFromPayload!
  createEntity(id: String, suffix: [String!], type: String!): ID!
  createInvitation(input: CreateInvitationInput!): Worker!
  createLocation(input: CreateLocationInput!): Location @semanticNonNull
  """
  Create a new template constraint.
  """
  createTemplateConstraint(
    entity: ID!
    options: TemplateConstraintOptions
    template: ID!
  ): CreateTemplateConstraintResult @semanticNonNull
  createUser(input: CreateUserInput!): User!
  createWorker(input: CreateWorkerInput!): WorkerEdge!
  """
  Deactivate an entity with the Activatable component. If the entity is already
  inactive, this operation is a no-op. Throws an error with code
  E_NOT_ACTIVATABLE if the entity being deactivated is not, in fact, Activatable.
  """
  deactivate(entity: ID!): Activatable!
  deactivateWorker(id: ID!): Worker!
  """
  Delete a Node.
  This operation is a no-op if the node has already been deleted.
  """
  deleteNode(node: ID!): [ID!] @semanticNonNull
  disableLanguage(languageId: ID!, orgId: ID!): EnabledLanguageEdge!
  enableLanguage(languageId: ID!, orgId: ID!): EnabledLanguageEdge!
  operateOnTask(ops: [TaskOperation!]!): TaskOperationResult @semanticNonNull
  saveChecklist(input: ChecklistInput!): ChecklistEdge!
  setStatus(
    entity: ID!
    input: ChecklistStatusInput!
    parent: ID
  ): SetStatusPayload!
  setValue(entity: ID!, input: WidgetInput!, parent: ID!): SetValuePayload!
  """
  Unssign an entity from another entity. If the entity is already unassigned,
  this operation is a no-op.

  Errors:
  - E_NOT_ASSIGNABLE, if either entity is not (un)assignable
  - E_ASSIGN_CONFLICT, if the entity is assigned to a different entity
  """
  unassign(entity: ID!, from: ID!): UnassignmentPayload!
  updateLocation(input: UpdateLocationInput!): Location @semanticNonNull
  updateName(input: UpdateNameInput!): Name!
  updateUser(input: UpdateUserInput!): User!
  updateWorker(input: UpdateWorkerInput!): WorkerEdge!
}

type Name implements Node {
  id: ID!
  language: Language!
  languageId: ID!
  metadata: NameMetadata!
  value: String!
}

type NameMetadata {
  nameId: ID!
  sourceLanguage: Language!
  sourceLanguageId: ID!
  sourceText: String!
  translatedAt: String!
}

"""
Indicates an object that is "refetchable".
"""
interface Node {
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
}

input NodeOperations @oneOf {
  activate: ActivateNodeOperation
  delete: DeleteNodeOperation
  publish: PublishNodeOperation
  rename: RenameNodeOperation
}

type NumberValue {
  number: Int
}

"""
TODO
"""
type NumberWidget implements Component {
  id: ID!
  number: Int
}

"""
TODO
"""
input NumberWidgetInput {
  value: Int
}

"""
TODO
"""
enum OffsetOptions {
  """
  TODO
  """
  auto
  """
  TODO
  """
  never
}

"""
Schedule implementation for "oneshot" events
"""
type OnceSchedule {
  once: Temporal!
}

type Open {
  openedAt: TimestampOverridable @semanticNonNull
  openedBy: Assignable
}

input OpenInput {
  openedAt: Timestamp
  openedBy: ID
}

type Organization implements Node {
  activatedAt: String
  active: Boolean!
  billingId: String
  deactivatedAt: String
  id: ID!
  languages(
    after: String
    before: String
    first: Int
    last: Int
    search: EnabledLanguageSearchOptions
  ): EnabledLanguageConnection!
  locations(
    after: String
    before: String
    first: Int
    last: Int
    search: LocationSearchOptions
  ): LocationConnection!
  me: Worker!
  name: Name!
  nameId: ID!
  workers(
    after: String
    before: String
    first: Int
    last: Int
    search: WorkerSearchOptions
  ): WorkerConnection!
}

type OrganizationConnection {
  edges: [OrganizationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type OrganizationEdge {
  node: Organization!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean @semanticNonNull
  hasPreviousPage: Boolean @semanticNonNull
  startCursor: String
}

input PublishNodeOperation {
  node: ID!
}

type Query {
  """
  For the given Assignable `entity`, returns a connection representing the set
  of Assignable entities to which the given `entity` can be assigned.

  Errors:
  - E_NOT_ASSIGNABLE, if `entity` is not assignable
  """
  assignable(entity: ID!): AssignableConnection!
  checklistAgg: ChecklistAggregate!
  checklists(
    after: String
    before: String
    first: Int
    last: Int
    parent: ID!
    sortBy: [ChecklistSortOrder!]
    withActive: Boolean
    withAssignee: [ID!]
    withDraft: Boolean
    withDueDate: TemporalRangeInput
    withName: String
    withStatus: [ChecklistStatusStates!]
  ): ChecklistConnection!
  entity(id: ID!): EntityConnection!
  languages: [Language!]!
  node(id: ID!): Node!
  roles: [Tag!]!
  """
  Query for Trackable entities in the given `parent` hierarchy.

  Note that this api does not yet support pagination! The `first` argument is
  used purely for testing at the moment.
  """
  trackables(
    """
    Forward pagination limit. Should only be used in conjunction with `after`.
    """
    first: Int
    """
    By default, this api will only return Trackables that are active. This can
    be overridden using the `includeInactive` flag.
    """
    includeInactive: Boolean
    """
    Identifies the root of the hierarchy in which to search for Trackable
    entities.

    Valid parent types are currently:
    - Customer

    All other parent types will be gracefully ignored.
    """
    parent: ID!
    """
    Allows filtering the returned set of Trackables by the *implementing* type.

    Currently this is only 'Location' (the default) or 'Task'. Note that
    specifying the latter will return a connection of trackable Tasks that
    represent the *chain roots* (i.e. originators). This is for you, Will
    Twait, so you can get started on the history screen. Note also that it will
    only give you *closed* chains, i.e. `workinstancecompleteddate is not null`.
    """
    withImplementation: String
  ): TrackableConnection @semanticNonNull
  user: User!
}

"""
Data type for tracking references to other object.
"""
type Reference {
  ref: Referenceable
}

"""
TODO
"""
type ReferenceWidget implements Component {
  id: ID!
  possibleTypes: [String!]!
  ref: Referenceable
}

"""
TODO
"""
input ReferenceWidgetInput {
  possibleTypes: [String!]!
  value: ID
}

interface Referenceable implements Component {
  id: ID!
}

"""
Data type for tracking named binaries (like strings). Any binary value can act
as the value of a register. Registers can only have the binaries stored within
them changed.
"""
type Register {
  binary: String
}

input RenameNodeOperation {
  name: String!
  node: ID!
}

type Requirement implements Component {
  id: ID!
  requires: ID!
}

"""
Controls how rounding is performed
"""
enum RoundingMode {
  """
  Always round up, towards the end of time
  """
  ceil
  """
  Always round down, towards the beginning of time
  """
  floor
}

"""
TODO
"""
union Schedule = CronSchedule | OnceSchedule

"""
TODO
"""
input ScheduleInput @oneOf {
  cron: String
  once: TemporalInput
}

"""
TODO
"""
enum ScheduleType {
  CronSchedule
  OnceSchedule
}

"""
TODO
"""
type SectionWidget implements Component {
  id: ID!
  title: String
}

"""
TODO
"""
input SectionWidgetInput {
  value: String
}

enum Sentiment {
  negative
  neutral
  positive
}

"""
TODO
"""
type SentimentWidget implements Component {
  id: ID!
  number: Int
}

"""
TODO
"""
input SentimentWidgetInput {
  value: Int
}

type SetChecklistItemStatusPayload implements SetStatusPayload {
  delta: Int!
  edge: ChecklistItemEdge!
  parent: Checklist!
}

type SetChecklistStatusPayload implements SetStatusPayload {
  delta: Int!
  edge: ChecklistEdge!
}

input SetFieldOperation {
  field: ID
  parent: ID
  value: ValueInput
  valueType: ValueType!
}

interface SetStatusPayload {
  delta: Int!
}

type SetValuePayload {
  delta: Int!
  node: ChecklistResult!
  parent: Checklist!
}

enum SmallestTimeUnit {
  millisecond
  minute
  second
}

"""
TODO
"""
type Sop implements Component {
  id: ID!
  sop: URL!
}

"""
TODO
"""
input SopInput {
  id: ID!
  link: URL!
}

"""
Defines the sort order for queries that support edge ordering.
Ordering depends on the scalar type:
  - Boolean scalars are sorted false < true
  - Int scalars are sorted numerically
  - String scalars are sorted lexicographically
"""
enum SortOrder {
  asc
  desc
}

"""
State characterizes something, most commonly an entity, as existing in a
particular state. For example, an entity could be in a "pending" state.
"""
interface State {
  tag: String
}

type StringValue {
  string: String
}

"""
TODO
"""
type StringWidget implements Component {
  id: ID!
  string: String
}

"""
TODO
"""
input StringWidgetInput {
  value: String
}

type Tag {
  id: ID!
  name: Name!
  nameId: ID!
  parent: Tag
  parentId: ID
  type: String!
}

"""
A system-level component that identifies an Entity as being applicable to
Tendrel's internal "task processing pipeline". In practice, Tasks most often
represent "jobs" performed by humans. However, this need not always be the
case.

Technically speaking, a Task represents a (1) *named asynchronous process*
that (2) exists in one of three states: open, in progress, or closed.
"""
type Task implements Assignable & Component & Node & Trackable {
  """
  [object Object],[object Object],[object Object]
  """
  assignees: AssignmentConnection
  """
  Attachments associated with the Task as a whole.
  Note that you can also have field-level attachments.
  """
  attachments(
    after: String
    before: String
    first: Int
    last: Int
  ): AttachmentConnection @semanticNonNull
  """
  Inspect the chain (if any) in which the given Task exists.
  As it stands, this can only be used to perform a downwards search of the
  chain, i.e. the given Task is used as the "root" of the search tree.
  """
  chain(
    """
    For use in pagination. Specifies the limit for "forward pagination".
    """
    first: Int
  ): TaskConnection @semanticNonNull
  """
  Given a Task identifying as a node in a chain, create an aggregate view of
  said chain over the type tags given in `overType`. The result is a set of
  aggregates representing the *sum total duration* of nodes tagged with any of
  the given `overType` tags, *including* the given Task (if it is so tagged).

  Colloquially: `chainAgg(overType: ["Foo", "Bar"])` will compute the total
  time spent in all "Foo" or "Bar" tasks in the given chain;

  ```json
  [
    {
      "group": "Foo",
      "value": "26.47", // 26.47 seconds spent doing "Foo" tasks
    },
    {
      "group": "Bar",
      "value": "5.82", // 5.82 seconds spent doing "Bar" tasks
    },
  ]
  ```

  Note that this aggregation uses the given Task as the *root* of the chain.
  Chains are tree-like structures, which means you can chainAgg over a subtree
  by choosing a different root node. Note also that this means you may need to
  do some math depending on the structure of your chain, e.g. in the above
  example it may be that "Foo" remains "InProgress" while "Bar" happens, and
  therefore the aggregate for "Foo" *includes* time spent in "Bar".
  """
  chainAgg(
    """
    Which subtype-hierarchies you are interested in aggregating over.
    """
    overType: [String!]!
  ): [Aggregate!] @semanticNonNull
  description: Description
  displayName: DisplayName
    @deprecated(reason: "Use Task.name instead.")
    @semanticNonNull
  """
  TODO: description.
  """
  fields: FieldConnection @semanticNonNull
  """
  Tasks can have an associated StateMachine, which defines a finite set of
  states that the given Task can be in at any given time.
  """
  fsm: TaskStateMachine
  """
  The hash signature of the given Task. This is only useful when interacting
  with APIs that require a hash as a concurrency control mechanism.
  """
  hash: String @semanticNonNull
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
  name: DisplayName @semanticNonNull
  """
  Identifies the parent of the current Task.

  This is different from previous. Previous models causality, parent models
  ownership. In practice, the parent of a Task will always be a Location.
  Note that currently this only supports workinstances. Tasks whose underlying
  type is a worktemplate will **always have a null parent**.
  """
  parent: Node
  """
  Get the previous Task, which may represent an altogether different chain
  than the current Task.
  """
  previous: Task
  state: TaskState
  """
  Entrypoint into the "tracking system(s)" for the given Task.
  At the moment, sub-task tracking is not supported and therefore `null` will
  always be returned for this field.
  """
  tracking(after: ID, first: Int): TrackableConnection
}

type TaskConnection {
  edges: [TaskEdge!] @semanticNonNull
  pageInfo: PageInfo @semanticNonNull
  totalCount: Int @semanticNonNull
}

type TaskEdge {
  cursor: String @semanticNonNull
  node: Task @semanticNonNull
}

input TaskOperation @oneOf {
  field: FieldOperations
  node: NodeOperations
  task: TaskOperations
}

type TaskOperationErr {
  """
  Fatal errors that caused the operation to fail.
  """
  errors: [Diagnostic!] @semanticNonNull
}

type TaskOperationOk {
  """
  The total count of operations applied as part of this operation.
  """
  count: Int @semanticNonNull
  """
  Nodes that were created as a result of this operation.
  """
  created: [Node!] @semanticNonNull
  """
  Nodes that were deleted as a result of this operation.
  """
  deleted: [ID!] @semanticNonNull
  """
  Nodes that were updated as a result of this operation.
  """
  updated: [Node!] @semanticNonNull
}

union TaskOperationResult = TaskOperationErr | TaskOperationOk

input TaskOperations @oneOf {
  advance: AdvanceTaskOperation
  assign: AssignTaskOperation
  instantiate: InstantiateTaskOperation
}

union TaskState = Closed | InProgress | Open

input TaskStateInput @oneOf {
  closed: ClosedInput
  inProgress: InProgressInput
  open: OpenInput
}

"""
Where applicable, Entities can have an associated StateMachine that defines
their current ("active") state in addition to possible next states that they
can "transition into". Typically, an end user does not need to be aware of
this state machine as Tendrel's internal engine maintains the machine and
associated states for a given Entity. However, in some cases it can be useful
to surface this information in userland such that a user can interact
directly with the underlying state machine.
"""
type TaskStateMachine {
  active: Task
  hash: String @semanticNonNull
  transitions: TaskConnection
}

enum TaskStateName {
  Closed
  InProgress
  Open
}

"""
Template constraints allow you to constrain the *type* of thing that can go
into a field. Currently, this is only supported for Locations (and by that I
mean "primary locations") as a means of "enabling" a template for the given
location.
"""
type TemplateConstraint {
  id: ID @semanticNonNull
}

input TemplateConstraintOptions {
  """
  Request eager instantiation of the given template.
  """
  instantiate: InstantiateOptions
}

interface Temporal {
  """
  Milliseconds since the UNIX epoch of 1/1/1970 00:00+00
  """
  epochMilliseconds: String!
}

input TemporalInput @oneOf {
  instant: String
  zdt: ZonedDateTimeInput
}

input TemporalRangeInput {
  after: TemporalInput
  before: TemporalInput
}

"""
TODO
"""
type TemporalWidget implements Component {
  id: ID!
  temporal: Temporal
}

"""
TODO
"""
input TemporalWidgetInput {
  value: TemporalInput
}

"""
A field whose value exists in the standard IANA Time Zone Database: https://www.iana.org/time-zones
"""
scalar TimeZone

"""
TODO
"""
enum TimeZoneNameOptions {
  """
  TODO
  """
  auto
  """
  TODO
  """
  critical
  """
  TODO
  """
  never
}

"""
A date-time string in ISO 8601 format.
"""
scalar Timestamp
  @specifiedBy(url: "https://www.rfc-editor.org/rfc/rfc3339.html#section-5.6")

type TimestampOverridable {
  override: TimestampOverride
  value: Timestamp @semanticNonNull
}

type TimestampOverride {
  overriddenAt: String
  overriddenBy: String
  previousValue: Timestamp @semanticNonNull
}

type TimestampValue {
  timestamp: Timestamp
}

"""
Identifies an Entity as being "trackable".
What exactly this means depends on the type underlying said entity and is
entirely user defined.
"""
interface Trackable implements Component {
  id: ID!
  """
  Entrypoint into the "tracking system(s)" for a given Entity. Note that while
  many types admit to being trackable, this does not mean that all in fact are
  in practice. In order for an Entity to be trackable, it must be explicitly
  configured as such.
  """
  tracking(after: ID, first: Int): TrackableConnection
}

type TrackableConnection {
  edges: [TrackableEdge!] @semanticNonNull
  pageInfo: PageInfo @semanticNonNull
  totalCount: Int @semanticNonNull
}

type TrackableEdge {
  cursor: String @semanticNonNull
  node: Trackable @semanticNonNull
}

scalar URL @specifiedBy(url: "https://www.ietf.org/rfc/rfc3986.txt")

type UnassignmentPayload {
  entity: Assignable!
  unassignedAssignees: [ID!]!
  unassignedFrom: Assignable! @deprecated
}

input UpdateLocationInput {
  activatedAt: String
  deactivatedAt: String
  geofence: GeofenceInput
  id: ID!
  name: UpdateNameInput
  scanCode: ID
}

input UpdateNameInput {
  activatedAt: String
  deactivatedAt: String
  id: ID!
  languageId: ID!
  value: String!
}

input UpdateUserInput {
  displayName: String
  firstName: String!
  id: ID!
  languageId: ID!
  lastName: String!
}

input UpdateWorkerInput {
  active: Boolean
  displayName: String
  firstName: String
  id: ID!
  languageId: ID
  lastName: String
  roleId: ID
  scanCode: ID
}

type User implements Node {
  activatedAt: String
  active: Boolean!
  authenticationIdentityId: ID
  authenticationProvider: Tag
  authenticationProviderId: ID
  deactivatedAt: String
  displayName: String!
  firstName: String!
  id: ID!
  language: Language!
  languageId: ID!
  lastName: String!
  organizations(
    after: String
    before: String
    first: Int
    last: Int
    withApp: [ApplicationType!]
  ): OrganizationConnection!
  tags: [Tag!]!
}

input UserSearchOptions {
  displayName: String
}

union Value =
  | BooleanValue
  | EntityValue
  | NumberValue
  | StringValue
  | TimestampValue

input ValueInput @oneOf {
  boolean: Boolean
  id: ID
  number: Int
  string: String
  """
  Date in either ISO or epoch millisecond format.
  """
  timestamp: String
}

enum ValueType {
  boolean
  entity
  number
  string
  timestamp
  unknown
}

"""
TODO
"""
union Widget =
  | BooleanWidget
  | CheckboxWidget
  | ClickerWidget
  | DurationWidget
  | MultilineStringWidget
  | NumberWidget
  | ReferenceWidget
  | SectionWidget
  | SentimentWidget
  | StringWidget
  | TemporalWidget

"""
TODO
"""
input WidgetInput @oneOf {
  boolean: BooleanWidgetInput
  checkbox: CheckboxWidgetInput
  clicker: ClickerWidgetInput
  duration: DurationWidgetInput
  multiline: MultilineStringWidgetInput
  number: NumberWidgetInput
  reference: ReferenceWidgetInput
  section: SectionWidgetInput
  sentiment: SentimentWidgetInput
  string: StringWidgetInput
  temporal: TemporalWidgetInput
}

type Worker implements Assignable & Component & Identity & Referenceable {
  _hack_numeric_id: Int!
  active: ActivationStatus!
  auth: AuthenticationStatus!
  displayName: String!
  firstName: String!
  id: ID!
  language: Language!
  languageId: ID!
  lastName: String!
  organizationId: ID!
  role: Tag!
  roleId: ID!
  scanCode: String
  tags: [Tag!]!
  user: User!
  userId: ID!
}

type WorkerConnection {
  edges: [WorkerEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type WorkerEdge {
  cursor: String!
  node: Worker!
}

input WorkerSearchOptions {
  active: Boolean
  displayName: String
  user: UserSearchOptions @deprecated(reason: "use displayName instead")
}

input WorkersQueryOptions {
  active: Boolean
  site: ID
}

"""
Timezone-aware, calendar-aware date/time object representing an exact time
from the perspective of a particular geographic region
"""
type ZonedDateTime implements Temporal {
  day: Int @semanticNonNull
  """
  Milliseconds since the UNIX epoch of 1/1/1970 00:00+00
  """
  epochMilliseconds: String!
  hour: Int @semanticNonNull
  millisecond: Int @semanticNonNull
  minute: Int @semanticNonNull
  month: Int @semanticNonNull
  second: Int @semanticNonNull
  timeZone: TimeZone!
  """
  Convert a ZonedDateTime to an ISO 8601 string
  """
  toString(options: ZonedDateTimeToStringOptions): String @semanticNonNull
  year: Int @semanticNonNull
}

input ZonedDateTimeInput {
  epochMilliseconds: String!
  timeZone: TimeZone!
}

input ZonedDateTimeToStringOptions {
  calendarName: CalendarNameOptions
  """
  How many digits to print after the decimal point in the output string
  """
  fractionalSecondDigits: Int
  offset: OffsetOptions
  """
  How to handle the remainder
  """
  roundingMode: RoundingMode
  """
  The smallest unit of time to include in the output string
  """
  smallestUnit: SmallestTimeUnit
  timeZoneName: TimeZoneNameOptions
}
