directive @semanticNonNull(levels: [Int] = [0]) on FIELD_DEFINITION

input AcceptInvitationInput {
  authenticationIdentityId: ID!
  workerId: ID!
}

"""
TODO
"""
type Activatable implements Component {
  active: Boolean!
  id: Entity!
  updatedAt: Temporal!
}

type ActivationStatus {
  activatedAt: String
  active: Boolean!
  deactivatedAt: String
}

"""
TODO
"""
input ActiveInput {
  active: Boolean!
  id: Entity!
  updatedAt: TemporalInput!
}

interface Assignable implements Component {
  id: Entity!
}

"""
TODO
"""
type Assignee implements Component {
  assignedAt: Temporal!
  assignedTo: Assignable!
  id: Entity!
}

type AssigneeConnection implements Connection {
  edges: [AssigneeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type AssigneeEdge implements Edge {
  cursor: String!
  node: Assignee!
}

"""
TODO
"""
input AssigneeInput {
  assignAt: TemporalInput!
  assignTo: Entity!
  id: Entity!
}

"""
TODO
"""
type Attachment implements Component {
  attachment: String!
  id: Entity!
}

type AttachmentConnection implements Connection {
  edges: [AttachmentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type AttachmentEdge implements Edge {
  cursor: String!
  node: Attachment!
}

"""
TODO
"""
type Auditable implements Component {
  enabled: Boolean!
  id: Entity!
}

"""
TODO
"""
input AuditableInput {
  enabled: Boolean!
  id: Entity!
}

type AuthenticationStatus {
  canLogin: Boolean!
  invitation: Invitation
}

"""
TODO
"""
enum CalendarNameOptions {
  """
  TODO
  """
  always

  """
  TODO
  """
  auto

  """
  TODO
  """
  critical

  """
  TODO
  """
  never
}

type Checklist implements Component {
  active: Activatable!
  assignees(
    after: String
    before: String
    first: Int
    last: Int
  ): AssigneeConnection!
  attachments(
    after: String
    before: String
    first: Int
    last: Int
  ): AttachmentConnection!
  auditable: Auditable!
  children(
    after: String
    before: String
    first: Int
    last: Int
    search: ChecklistSearchOptions
  ): ChecklistConnection!
  description: Description
  id: Entity!
  items(
    after: String
    before: String
    first: Int
    last: Int
  ): ChecklistItemConnection!
  metadata: Metadata!
  name: DisplayName!
  required: Boolean
  schedule: Schedule
  sop: Sop
  status: ChecklistStatus
}

type ChecklistClosed implements Component {
  closedAt: Temporal!
  closedBecause: ChecklistClosedReason!
  closedBy: Identity!
  id: Entity!
}

input ChecklistClosedInput {
  at: TemporalInput!
  because: ChecklistClosedReasonInput!
  by: Entity!
  id: Entity!
}

type ChecklistClosedReason {
  code: ChecklistClosedReasonCode!
  note: DynamicString
}

enum ChecklistClosedReasonCode {
  error
  success
}

input ChecklistClosedReasonInput {
  code: ChecklistClosedReasonCode!
  note: DynamicStringInput
}

type ChecklistConnection implements Connection {
  edges: [ChecklistEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ChecklistEdge implements Edge {
  cursor: String!
  node: Checklist!
}

type ChecklistInProgress implements Component {
  id: Entity!
  inProgressAt: Temporal!
  inProgressBy: Identity!
}

input ChecklistInProgressInput {
  at: TemporalInput!
  by: Entity!
  id: Entity!
}

input ChecklistInput {
  active: ActiveInput!
  assignees: [AssigneeInput!]
  auditable: AuditableInput!
  customerId: ID!
  description: DescriptionInput
  id: Entity!
  items: [ChecklistItemInput!]
  name: DisplayNameInput!
  required: Boolean
  schedule: ScheduleInput
  sop: SopInput
  status: ChecklistStatusInput
}

union ChecklistItem = Checklist | ChecklistResult

type ChecklistItemConnection implements Connection {
  edges: [ChecklistItemEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ChecklistItemEdge implements Edge {
  cursor: String!
  node: ChecklistItem!
}

input ChecklistItemInput @oneOf {
  checklist: ChecklistInput
  result: ChecklistResultInput
}

type ChecklistOpen implements Component {
  id: Entity!
  openedAt: Temporal!
  openedBy: Identity!
}

input ChecklistOpenInput {
  at: TemporalInput!
  by: Entity!
  id: Entity!
}

"""
TODO
"""
type ChecklistResult implements Component {
  assignees(
    after: String
    before: String
    first: Int
    last: Int
  ): AssigneeConnection!
  attachments(
    after: String
    before: String
    first: Int
    last: Int
  ): AttachmentConnection!
  auditable: Auditable!
  id: Entity!
  name: DisplayName!
  required: Boolean
  status: ChecklistStatus
  value: ChecklistResultValue
}

"""
TODO
"""
input ChecklistResultInput {
  assignees: [AssigneeInput!]!
  auditable: AuditableInput!
  id: Entity!
  name: DisplayNameInput!
  required: Boolean
  status: ChecklistStatusInput
  value: ChecklistResultValueInput
}

union ChecklistResultValue = Counter | Flag | Register

input ChecklistResultValueInput @oneOf {
  counter: Int
  flag: Boolean
  register: String
}

input ChecklistSearchOptions {
  active: Boolean
  order: ChecklistSearchOrderOptions
}

input ChecklistSearchOrderOptions {
  completedAt: SortOrder
}

union ChecklistStatus = ChecklistClosed | ChecklistInProgress | ChecklistOpen

input ChecklistStatusInput @oneOf {
  closed: ChecklistClosedInput
  inProgress: ChecklistInProgressInput
  open: ChecklistOpenInput
}

"""
Components characterize Entities as possessing a particular trait.
They are just simple structs, holding all data necessary to model that trait.
"""
interface Component {
  id: Entity!
}

interface Connection {
  pageInfo: PageInfo!
  totalCount: Int!
}

"""
Data type for tracking an incrementable/decrementable integer value.
Counters have two operations: increment and decrement.
"""
type Counter {
  count: Int!
}

input CreateInvitationInput {
  emailAddress: String!
  orgId: ID!
  redirectUrl: String
  workerId: ID!
}

input CreateLocationInput {
  active: Boolean!
  id: ID
  name: CreateNameInput!
  orgId: ID!
  scanCode: ID
}

input CreateNameInput {
  active: Boolean!
  id: ID
  languageId: ID!
  value: String!
}

input CreateUserInput {
  active: Boolean!
  displayName: String
  firstName: String!
  identityId: String!
  lastName: String!
  username: String
}

input CreateWorkerInput {
  active: Boolean!
  displayName: String
  firstName: String!
  id: ID
  languageId: ID!
  lastName: String!
  orgId: ID!
  roleId: ID!
  scanCode: ID
  userId: ID
}

"""
A string representing a cron schedule expression
"""
scalar CronExpression

"""
Schedule implementation using cron expressions
"""
type CronSchedule {
  cron: CronExpression!
}

"""
TODO
"""
type Description implements Component {
  id: Entity!
  value: DynamicString!
}

"""
TODO
"""
input DescriptionInput {
  id: Entity!
  value: DynamicStringInput!
}

"""
TODO
"""
type DisplayName implements Component {
  id: Entity!
  value: DynamicString!
}

"""
TODO
"""
input DisplayNameInput {
  id: Entity!
  value: DynamicStringInput!
}

scalar Duration

"""
TODO
"""
type DynamicString {
  locale: Locale!
  value: String!
}

"""
TODO
"""
input DynamicStringInput {
  locale: Locale!
  value: String!
}

interface Edge {
  cursor: String!
}

type EnabledLanguage implements Node {
  active: ActivationStatus!
  id: ID!
  language: Language!
  languageId: ID!
  primary: Boolean!
}

type EnabledLanguageConnection {
  edges: [EnabledLanguageEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type EnabledLanguageEdge {
  cursor: String!
  node: EnabledLanguage!
}

input EnabledLanguageSearchOptions {
  active: Boolean
  primary: Boolean
}

scalar Entity

type EntityComponentConnection implements Connection {
  edges: [EntityComponentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type EntityComponentEdge implements Edge {
  cursor: String!
  node: Component!
}

type EntityConnection {
  components(
    after: String
    before: String
    first: Int
    last: Int
  ): EntityComponentConnection!
  entity: Entity!
}

"""
Data type for tracking Boolean-like values in the form of "enabled" or
"disabled".
Flags only support two operations: enable and disable.
"""
type Flag {
  enabled: Boolean!
}

interface Identity implements Component {
  id: Entity!
}

"""
Fixed point in time (i.e. "exact time") without regard to calendar or location
"""
type Instant implements Temporal {
  """
  Milliseconds since the UNIX epoch of 1/1/1970 00:00+00
  """
  epochMilliseconds: String!

  """
  Convert an Instant to an ISO 8601 string
  """
  toString(options: InstantToStringOptions): String

  """
  Convert an Instant to a ZonedDateTime
  """
  toZonedDateTime(timeZone: TimeZone!): ZonedDateTime
}

input InstantToStringOptions {
  """
  How many digits to print after the decimal point in the output string
  """
  fractionalSecondDigits: Int

  """
  How to handle the remainder
  """
  roundingMode: RoundingMode

  """
  The smallest unit of time to include in the output string
  """
  smallestUnit: SmallestTimeUnit

  """
  The time zone to express the Instant/ZonedDateTime in
  """
  timeZone: TimeZone
}

type Invitation {
  createdAt: String!
  emailAddress: String!
  id: ID!
  status: InvitationStatus!
  updatedAt: String!
  workerId: ID!
}

enum InvitationStatus {
  accepted
  pending
  revoked
}

type Language {
  code: String!
  id: ID!
  name: Name!
  nameId: ID!
}

scalar Locale

type Location implements Node {
  active: ActivationStatus!
  children(options: LocationsQueryOptions): [Location!]!
  id: ID!
  name: Name!
  nameId: ID!
  parent: Location
  parentId: ID
  scanCode: ID
  site: Location!
  siteId: ID!
  tags: [Tag!]!
  timeZone: String!
}

type LocationConnection {
  edges: [LocationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type LocationEdge {
  cursor: String!
  node: Location!
}

input LocationSearchOptions {
  active: Boolean
  isSite: Boolean
}

input LocationsQueryOptions {
  cornerstone: Boolean
  site: Boolean
}

"""
Metadata pertaining to an individual Entity, e.g. when it was last updated and
by whom.
"""
type Metadata {
  updatedAt: Temporal!
  updatedBy: Identity
}

type Mutation {
  acceptInvitation(input: AcceptInvitationInput!): Worker!
  activateWorker(id: ID!): Worker!
  createEntity(id: String, suffix: [String!], type: String!): Entity!
  createInvitation(input: CreateInvitationInput!): Worker!
  createLocation(input: CreateLocationInput!): Location!
  createUser(input: CreateUserInput!): User!
  createWorker(input: CreateWorkerInput!): WorkerEdge!
  deactivateWorker(id: ID!): Worker!
  disableLanguage(languageId: ID!, orgId: ID!): EnabledLanguageEdge!
  enableLanguage(languageId: ID!, orgId: ID!): EnabledLanguageEdge!
  saveChecklist(input: ChecklistInput!): ChecklistEdge!
  signUp(input: SignUpInput!): User!
  updateLocation(input: UpdateLocationInput!): Location!
  updateName(input: UpdateNameInput!): Name!
  updateUser(input: UpdateUserInput!): User!
  updateWorker(input: UpdateWorkerInput!): WorkerEdge!
}

type Name implements Node {
  id: ID!
  language: Language!
  languageId: ID!
  metadata: NameMetadata!
  value: String!
}

type NameMetadata {
  nameId: ID!
  sourceLanguage: Language!
  sourceLanguageId: ID!
  sourceText: String!
  translatedAt: String!
}

interface Node {
  id: ID!
}

"""
TODO
"""
enum OffsetOptions {
  """
  TODO
  """
  auto

  """
  TODO
  """
  never
}

"""
Schedule implementation for "oneshot" events
"""
type OnceSchedule {
  once: Temporal!
}

type Organization implements Node {
  activatedAt: String
  active: Boolean!
  billingId: String
  deactivatedAt: String
  id: ID!
  languages(
    after: String
    before: String
    first: Int
    last: Int
    search: EnabledLanguageSearchOptions
  ): EnabledLanguageConnection!
  locations(
    after: String
    before: String
    first: Int
    last: Int
    search: LocationSearchOptions
  ): LocationConnection!
  me: Worker!
  name: Name!
  nameId: ID!
  workers(
    after: String
    before: String
    first: Int
    last: Int
    search: WorkerSearchOptions
  ): WorkerConnection!
}

type OrganizationConnection {
  edges: [OrganizationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type OrganizationEdge {
  node: Organization!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  checklists(
    after: String
    before: String
    first: Int
    last: Int
    search: ChecklistSearchOptions
  ): ChecklistConnection!
  entity(id: Entity!): EntityConnection!
  languages: [Language!]!
  node(id: ID!): Node!
  roles: [Tag!]!
  user: User!
}

"""
Data type for tracking named binaries (like strings). Any binary value can act
as the value of a register. Registers can only have the binaries stored within
them changed.
"""
type Register {
  binary: String!
}

"""
Controls how rounding is performed
"""
enum RoundingMode {
  """
  Always round up, towards the end of time
  """
  ceil

  """
  Always round down, towards the beginning of time
  """
  floor
}

"""
TODO
"""
union Schedule = CronSchedule | OnceSchedule

"""
TODO
"""
input ScheduleInput @oneOf {
  cron: String
  once: TemporalInput
}

"""
TODO
"""
enum ScheduleType {
  CronSchedule
  OnceSchedule
}

input SignUpInput {
  active: Boolean!
  displayName: String
  firstName: String!
  identityId: String!
  lastName: String!
  username: String
}

enum SmallestTimeUnit {
  millisecond
  minute
  second
}

"""
TODO
"""
type Sop implements Component {
  id: Entity!
  link: URL!
}

"""
TODO
"""
input SopInput {
  id: Entity!
  link: URL!
}

"""
Defines the sort order for queries that support edge ordering.
Ordering depends on the scalar type:
  - Boolean scalars are sorted false < true
  - Int scalars are sorted numerically
  - String scalars are sorted lexicographically
"""
enum SortOrder {
  asc
  desc
}

type Tag {
  id: ID!
  name: Name!
  nameId: ID!
  parent: Tag
  parentId: ID
  type: String!
}

interface Temporal {
  """
  Milliseconds since the UNIX epoch of 1/1/1970 00:00+00
  """
  epochMilliseconds: String!
}

input TemporalInput @oneOf {
  instant: String
  zdt: ZonedDateTimeInput
}

scalar TimeZone

"""
TODO
"""
enum TimeZoneNameOptions {
  """
  TODO
  """
  auto

  """
  TODO
  """
  critical

  """
  TODO
  """
  never
}

scalar URL

input UpdateLocationInput {
  activatedAt: String
  deactivatedAt: String
  id: ID!
  name: UpdateNameInput
  scanCode: ID
}

input UpdateNameInput {
  activatedAt: String
  deactivatedAt: String
  id: ID!
  languageId: ID!
  value: String!
}

input UpdateUserInput {
  displayName: String
  firstName: String!
  id: ID!
  languageId: ID!
  lastName: String!
}

input UpdateWorkerInput {
  active: Boolean
  displayName: String
  firstName: String
  id: ID!
  languageId: ID
  lastName: String
  roleId: ID
  scanCode: ID
}

type User implements Node {
  activatedAt: String
  active: Boolean!
  authenticationIdentityId: ID
  authenticationProvider: Tag
  authenticationProviderId: ID
  deactivatedAt: String
  displayName: String!
  firstName: String!
  id: ID!
  language: Language!
  languageId: ID!
  lastName: String!
  organizations(
    after: String
    before: String
    first: Int
    last: Int
  ): OrganizationConnection!
  tags: [Tag!]!
}

input UserSearchOptions {
  displayName: String
}

type Worker implements Assignable & Component & Identity {
  _hack_numeric_id: Int!
  active: ActivationStatus!
  auth: AuthenticationStatus!
  displayName: String!
  firstName: String!
  id: Entity!
  language: Language!
  languageId: ID!
  lastName: String!
  organizationId: ID!
  role: Tag!
  roleId: ID!
  scanCode: String
  tags: [Tag!]!
  user: User!
  userId: ID!
}

type WorkerConnection {
  edges: [WorkerEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type WorkerEdge {
  cursor: String!
  node: Worker!
}

input WorkerSearchOptions {
  active: Boolean
  user: UserSearchOptions
}

input WorkersQueryOptions {
  active: Boolean
  site: ID
}

"""
Timezone-aware, calendar-aware date/time object representing an exact time
from the perspective of a particular geographic region
"""
type ZonedDateTime implements Temporal {
  day: Int!

  """
  Milliseconds since the UNIX epoch of 1/1/1970 00:00+00
  """
  epochMilliseconds: String!
  hour: Int!
  millisecond: Int!
  minute: Int!
  month: Int!
  second: Int!
  timeZone: TimeZone!

  """
  Convert a ZonedDateTime to an ISO 8601 string
  """
  toString(options: ZonedDateTimeToStringOptions): String!
  year: Int!
}

input ZonedDateTimeInput {
  epochMilliseconds: String!
  timeZone: TimeZone!
}

input ZonedDateTimeToStringOptions {
  calendarName: CalendarNameOptions

  """
  How many digits to print after the decimal point in the output string
  """
  fractionalSecondDigits: Int
  offset: OffsetOptions

  """
  How to handle the remainder
  """
  roundingMode: RoundingMode

  """
  The smallest unit of time to include in the output string
  """
  smallestUnit: SmallestTimeUnit
  timeZoneName: TimeZoneNameOptions
}
