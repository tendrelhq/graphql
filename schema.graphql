input AcceptInvitationInput {
  authenticationIdentityId: ID!
  workerId: ID!
}

"""TODO"""
type Activatable implements Component {
  active: Boolean!
  id: Entity!
  updatedAt: Temporal!
}

input ActivatableTypeInput {
  activatedAt: String
  active: Boolean!
}

"""TODO"""
type Actor implements Component {
  id: Entity!
  user: User!
}

"""TODO"""
type Assignee implements Component {
  assignedAt: Temporal!
  assignedTo: Actor!
  id: Entity!
}

type AssigneeConnection implements Connection {
  edges: [AssigneeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type AssigneeEdge implements Edge {
  cursor: String!
  node: Assignee!
}

input AssigneesTypeInput {
  maxAllowed: Int
  minAllowed: Int
}

"""TODO"""
type Attachment implements Component {
  attachment: String!
  id: Entity!
}

type AttachmentConnection implements Connection {
  edges: [AttachmentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type AttachmentEdge implements Edge {
  cursor: String!
  node: Attachment!
}

"""TODO"""
type Auditable implements Component {
  enabled: Boolean!
  id: Entity!
}

input AuditableTypeInput {
  auditable: Boolean!
}

"""TODO"""
enum CalendarNameOptions {
  """TODO"""
  always

  """TODO"""
  auto

  """TODO"""
  critical

  """TODO"""
  never
}

type Checklist implements Component {
  active: Activatable!
  assignees(after: String, before: String, first: Int, last: Int): AssigneeConnection!
  attachments(after: String, before: String, first: Int, last: Int): AttachmentConnection!
  auditable: Auditable!
  children: ChecklistConnection!
  description: Description
  id: Entity!
  items(after: String, before: String, first: Int, last: Int): ChecklistConnection!
  name: DisplayName!
  required: Boolean
  schedule: Schedule
  sop: Sop
  status: ChecklistStatus!
}

type ChecklistClosed implements Component {
  closedAt: Temporal!
  closedBecause: ChecklistClosedReason!
  closedBy: Actor!
  id: Entity!
}

type ChecklistClosedReason {
  code: ChecklistClosedReasonCode!
  note: DynamicString
}

enum ChecklistClosedReasonCode {
  error
  success
}

type ChecklistConnection implements Connection {
  edges: [ChecklistEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ChecklistEdge implements Edge {
  cursor: String!
  node: ChecklistItem!
  type: ChecklistType!
}

type ChecklistInProgress implements Component {
  id: Entity!
  inProgressAt: Temporal!
  inProgressBy: Actor!
}

union ChecklistItem = Checklist | ChecklistResult

type ChecklistItemType implements Component {
  description: Description!
  id: Entity!
  name: DisplayName!
  type: Type!
}

type ChecklistOpen implements Component {
  id: Entity!
  openedAt: Temporal!
  openedBy: Actor
}

type ChecklistResult implements Component {
  assignees(after: String, before: String, first: Int, last: Int): AssigneeConnection!
  attachments(after: String, before: String, first: Int, last: Int): AttachmentConnection!
  auditable: Auditable!
  id: Entity!
  name: DisplayName!
  required: Boolean
  status: ChecklistStatus!
  value: ChecklistResultValue!
}

union ChecklistResultValue = Counter | Flag | Register

union ChecklistStatus = ChecklistClosed | ChecklistInProgress | ChecklistOpen

type ChecklistType implements Component {
  description: Description!
  id: Entity!
  items: [ChecklistItemType!]!
  name: DisplayName!
}

input ChecklistTypeInput {
  active: ActivatableTypeInput!
  assignees: AssigneesTypeInput!
  auditable: AuditableTypeInput!
  description: DescriptionInput!
  id: Entity!
  name: DisplayNameInput!
  required: RequiredTypeInput!
  schedule: ScheduleTypeInput!
  sop: SopTypeInput!
  status: StatusTypeInput!
}

"""
Components characterize Entities as possessing a particular trait.
They are just simple structs, holding all data necessary to model that trait.
"""
interface Component {
  id: Entity!
}

type ComponentConstructor {
  node(id: ID!): NodeConstructor!
  type(type: String!): TypeConstructor!
}

interface Connection {
  pageInfo: PageInfo!
  totalCount: Int!
}

"""
Data type for tracking an incrementable/decrementable integer value.
Counters have two operations: increment and decrement.
"""
type Counter {
  count: Int
}

type CounterNode {
  count(value: Int!): Void
}

type CreateEntity {
  components: CreateEntityComponentConnection!
  id: Entity!
}

type CreateEntityComponentConnection {
  node(id: Entity!): CreateEntityComponentNode!
  type(type: String!): CreateEntityComponentType!
}

union CreateEntityComponentNode = CreateLeafNode | CreateNamedNode

type CreateEntityComponentType {
  components: CreateEntityComponentConnection!
  description(locale: Locale, value: String!): Void
  name(locale: Locale, value: String!): Void
}

input CreateInvitationInput {
  emailAddress: String!
  orgId: ID!
  workerId: ID!
}

type CreateLeafNode {
  value: ValueNode
}

input CreateLocationInput {
  active: Boolean!
  id: ID
  name: CreateNameInput!
  orgId: ID!
  scanCode: ID
}

input CreateNameInput {
  active: Boolean!
  id: ID
  languageId: ID!
  value: String!
}

type CreateNamedNode {
  components: CreateEntityComponentConnection!
  description(locale: Locale, value: String!): Void
  name(locale: Locale, value: String!): Void
}

input CreateUserInput {
  active: Boolean!
  displayName: String
  firstName: String!
  id: ID
  languageId: ID!
  lastName: String!
  username: String
}

input CreateWorkerInput {
  active: Boolean!
  id: ID
  languageId: ID!
  orgId: ID!
  roleId: ID!
  scanCode: ID
  userId: ID!
}

"""A string representing a cron schedule expression"""
scalar CronExpression

"""Schedule implementation using cron expressions"""
type CronSchedule {
  cron: CronExpression!
}

"""TODO"""
type Description implements Component {
  id: Entity!
  value: DynamicString!
}

input DescriptionInput {
  locale: Locale!
  value: String!
}

"""TODO"""
type DisplayName implements Component {
  id: Entity!
  value: DynamicString!
}

input DisplayNameInput {
  locale: Locale!
  value: String!
}

"""ISO 8601 duration string expressing a length of time"""
scalar Duration

"""TODO"""
type DynamicString {
  locale: Locale!
  value: String!
}

interface Edge {
  cursor: String!
}

type EnabledLanguage implements Node {
  activatedAt: String
  active: Boolean!
  deactivatedAt: String
  id: ID!
  language: Language!
  languageId: ID!
  primary: Boolean!
}

type EnabledLanguageConnection {
  edges: [EnabledLanguageEdge!]!
  pageInfo: PageInfo!
}

type EnabledLanguageEdge {
  node: EnabledLanguage!
}

"""
An entity represents a general-purpose object. The scalar representation is
just an opaque string, similar to ID.
"""
scalar Entity

type EntityComponentConnection implements Connection {
  edges: [EntityComponentEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type EntityComponentEdge implements Edge {
  cursor: String!
  node: Component!
}

type EntityConnection {
  components(after: String, before: String, first: Int, last: Int): EntityComponentConnection!
  entity: Entity!
}

type Field {
  description: String
  name: String!
  type: Type!
}

"""
Data type for tracking Boolean-like values in the form of "enabled" or
"disabled".
Flags only support two operations: enable and disable.
"""
type Flag {
  enabled: Boolean
}

type FlagNode {
  flag(value: Boolean!): Void
}

"""
Fixed point in time (i.e. "exact time") without regard to calendar or location
"""
type Instant {
  """Milliseconds since the UNIX epoch of 1/1/1970 00:00+00"""
  epochMilliseconds: String!

  """Convert an Instant to an ISO 8601 string"""
  toString(options: InstantToStringOptions): String!

  """Convert an Instant to a ZonedDateTime"""
  toZonedDateTime(timeZone: TimeZone!): ZonedDateTime!
}

input InstantToStringOptions {
  """How many digits to print after the decimal point in the output string"""
  fractionalSecondDigits: Int

  """How to handle the remainder"""
  roundingMode: RoundingMode

  """The smallest unit of time to include in the output string"""
  smallestUnit: SmallestTimeUnit

  """The time zone to express the Instant/ZonedDateTime in"""
  timeZone: TimeZone
}

type Invitation {
  createdAt: String!
  emailAddress: String!
  id: ID!
  status: InvitationStatus!
  updatedAt: String!
  workerId: ID!
}

enum InvitationStatus {
  accepted
  pending
  revoked
}

type Language {
  code: String!
  id: ID!
  name: Name!
  nameId: ID!
}

"""TODO"""
scalar Link

"""
A string representing a locale conforming to the BCP 47 (RFC 5646) standard
"""
scalar Locale

type Location implements Node {
  activatedAt: String
  active: Boolean!
  children(options: LocationsQueryOptions): [Location!]!
  deactivatedAt: String
  id: ID!
  name: Name!
  nameId: ID!
  parent: Location
  parentId: ID
  scanCode: ID
  site: Location!
  siteId: ID!
  tags: [Tag!]!
}

type LocationConnection {
  edges: [LocationEdge!]!
  pageInfo: PageInfo!
}

type LocationEdge {
  node: Location!
}

input LocationsQueryOptions {
  cornerstone: Boolean
  site: Boolean
}

type Mutation {
  acceptInvitation(input: AcceptInvitationInput!): Worker!
  activateWorker(id: ID!): Worker!
  createChecklistType(input: ChecklistTypeInput!): ChecklistType!
  createEntity: CreateEntity!
  createInvitation(input: CreateInvitationInput!): Invitation!
  createLocation(input: CreateLocationInput!): Location!
  createUser(input: CreateUserInput!): User!
  createWorker(input: CreateWorkerInput!): Worker!
  deactivateWorker(id: ID!): Worker!
  disableLanguage(languageId: ID!, orgId: ID!): Boolean!
  enableLanguage(languageId: ID!, orgId: ID!): Boolean!
  updateLocation(input: UpdateLocationInput!): Location!
  updateName(input: UpdateNameInput!): Name!
  updateUser(input: UpdateUserInput!): User!
  updateWorker(input: UpdateWorkerInput!): Worker!
}

type Name implements Node {
  id: ID!
  language: Language!
  languageId: ID!
  metadata: NameMetadata!
  value: String!
}

type NameMetadata {
  nameId: ID!
  sourceLanguage: Language!
  sourceLanguageId: ID!
  sourceText: String!
  translatedAt: String!
}

interface Node {
  id: ID!
}

type NodeConstructor {
  description(locale: Locale, value: String!): Void
  name(locale: Locale, value: String!): Void
}

"""TODO"""
enum OffsetOptions {
  """TODO"""
  auto

  """TODO"""
  never
}

"""Schedule implementation for "oneshot" events"""
type OnceSchedule {
  once: Temporal!
}

type Organization implements Node {
  activatedAt: String
  active: Boolean!
  billingId: String
  deactivatedAt: String
  id: ID!
  languages(after: String, before: String, first: Int, last: Int): EnabledLanguageConnection!
  locations(after: String, before: String, first: Int, last: Int): LocationConnection!
  name: Name!
  nameId: ID!
  workers(after: String, before: String, first: Int, last: Int): WorkerConnection!
}

type OrganizationConnection {
  edges: [OrganizationEdge!]!
  pageInfo: PageInfo!
}

type OrganizationEdge {
  node: Organization!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Query {
  checklists(after: String, before: String, first: Int, last: Int): ChecklistConnection!
  entity(id: Entity!): EntityConnection!
  languages: [Language!]!
  node(id: ID!): Node!
  roles: [Tag!]!
  user: User!
}

"""
Data type for tracking named binaries (like strings). Any binary value can act
as the value of a register. Registers can only have the binaries stored within
them changed.
"""
type Register {
  binary: String
}

type RegisterNode {
  register(value: String!): Void
}

input RequiredTypeInput {
  required: Boolean!
}

"""Controls how rounding is performed"""
enum RoundingMode {
  """Always round up, towards the end of time"""
  ceil

  """Always round down, towards the beginning of time"""
  floor
}

"""TODO"""
union Schedule = CronSchedule | OnceSchedule

input ScheduleTypeInput {
  kind: String!
}

enum SmallestTimeUnit {
  millisecond
  minute
  second
}

"""TODO"""
type Sop implements Component {
  id: Entity!
  link: Link!
}

input SopTypeInput {
  link: Link!
}

input StatusTypeInput {
  default: String!
}

type Tag {
  id: ID!
  name: Name!
  nameId: ID!
  parent: Tag
  parentId: ID
  type: String!
}

union Temporal = Instant | ZonedDateTime

"""IANA time zone, UTC offset, or UTC itself"""
scalar TimeZone

"""TODO"""
enum TimeZoneNameOptions {
  """TODO"""
  auto

  """TODO"""
  critical

  """TODO"""
  never
}

type Type {
  description: String
  fields: [Field!]
  kind: TypeKind!
  name: String
  ofType: Type
  possibleTypes: [Type!]
  possibleValues: [Value!]
}

type TypeConstructor {
  description(locale: Locale, value: String!): Void
  name(locale: Locale, value: String!): Void
}

enum TypeKind {
  COUNTER
  FLAG
  REGISTER
}

input UpdateLocationInput {
  activatedAt: String
  deactivatedAt: String
  id: ID!
  name: UpdateNameInput
  scanCode: ID
}

input UpdateNameInput {
  activatedAt: String
  deactivatedAt: String
  id: ID!
  languageId: ID!
  value: String!
}

input UpdateUserInput {
  displayName: String
  firstName: String!
  id: ID!
  languageId: ID!
  lastName: String!
}

input UpdateWorkerInput {
  activatedAt: String
  deactivatedAt: String
  id: ID!
  languageId: ID!
  roleId: ID!
  scanCode: ID
}

type User implements Node {
  activatedAt: String
  active: Boolean!
  authenticationIdentityId: ID
  authenticationProvider: Tag
  authenticationProviderId: ID
  deactivatedAt: String
  displayName: String!
  firstName: String!
  id: ID!
  language: Language!
  languageId: ID!
  lastName: String!
  organizations(after: String, before: String, first: Int, last: Int): OrganizationConnection!
  tags: [Tag!]!
}

type Value {
  description: String
  name: String!
}

union ValueNode = CounterNode | FlagNode | RegisterNode

scalar Void

type Worker implements Node {
  activatedAt: String
  active: Boolean!
  deactivatedAt: String
  id: ID!
  invitation: Invitation
  invitationId: ID
  language: Language!
  languageId: ID!
  role: Tag!
  roleId: ID!
  scanCode: String
  tags: [Tag!]!
  user: User!
  userId: ID!
}

type WorkerConnection {
  edges: [WorkerEdge!]!
  pageInfo: PageInfo!
}

type WorkerEdge {
  node: Worker!
}

input WorkersQueryOptions {
  active: Boolean
  site: ID
}

"""
Timezone-aware, calendar-aware date/time object representing an exact time
from the perspective of a particular geographic region
"""
type ZonedDateTime {
  day: Int!

  """Milliseconds since the UNIX epoch of 1/1/1970 00:00+00"""
  epochMilliseconds: String!
  hour: Int!
  millisecond: Int!
  minute: Int!
  month: Int!
  second: Int!
  timeZone: TimeZone!

  """Convert a ZonedDateTime to an ISO 8601 string"""
  toString(options: ZonedDateTimeToStringOptions): String!
  year: Int!
}

input ZonedDateTimeToStringOptions {
  calendarName: CalendarNameOptions

  """How many digits to print after the decimal point in the output string"""
  fractionalSecondDigits: Int
  offset: OffsetOptions

  """How to handle the remainder"""
  roundingMode: RoundingMode

  """The smallest unit of time to include in the output string"""
  smallestUnit: SmallestTimeUnit
  timeZoneName: TimeZoneNameOptions
}