type Query {
  checklists(
    first: Int
    last: Int
    before: String
    after: String
  ): ChecklistConnection!
}

type Mutation {
  createChecklistType(input: ChecklistTypeInput!): ChecklistType!
}

input ChecklistTypeInput {
  id: Entity!
  active: ActivatableTypeInput!
  assignees: AssigneesTypeInput!
  auditable: AuditableTypeInput!
  description: DescriptionInput!
  name: DisplayNameInput!
  required: RequiredTypeInput!
  schedule: ScheduleTypeInput!
  sop: SopTypeInput!
  status: StatusTypeInput!
}

input ActivatableTypeInput {
  active: Boolean!
  activatedAt: String # todo: TemporalInput?
}

input AssigneesTypeInput {
  minAllowed: Int
  maxAllowed: Int
}

input AuditableTypeInput {
  auditable: Boolean!
}

input DescriptionInput {
  locale: Locale!
  value: String!
}

input DisplayNameInput {
  locale: Locale!
  value: String!
}

input RequiredTypeInput {
  required: Boolean!
}

input ScheduleTypeInput {
  kind: String!
}

input SopTypeInput {
  link: Link!
}

input StatusTypeInput {
  default: String!
}

type Checklist implements Component {
  id: Entity!
  active: Activatable!
  assignees(
    first: Int
    last: Int
    before: String
    after: String
  ): AssigneeConnection!
  attachments(
    first: Int
    last: Int
    before: String
    after: String
  ): AttachmentConnection!
  auditable: Auditable!
  description: Description
  items(
    first: Int
    last: Int
    before: String
    after: String
  ): ChecklistItemConnection!
  name: DisplayName!
  required: Boolean
  schedule: Schedule
  sop: Sop
  status: ChecklistStatus!
  # TODO: not sure about this... :/
  children: ChecklistConnection!
}

type ChecklistItemConnection implements Connection {
  edges: [ChecklistItemEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ChecklistItemEdge implements Edge {
  cursor: String!
  node: ChecklistItem!
}

type ChecklistConnection implements Connection {
  edges: [ChecklistEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ChecklistEdge implements Edge {
  cursor: String!
  node: Checklist!
}

type ChecklistType implements Component {
  id: Entity!
  name: DisplayName!
  description: Description!
  items: [ChecklistItemType!]!
}

type ChecklistItemType implements Component {
  id: Entity!
  name: DisplayName!
  description: Description!
  type: Type!
}

## We want our checklists to support nesting
union ChecklistItem = Checklist | ChecklistResult

type ChecklistResult implements Component {
  id: Entity!
  assignees(
    first: Int
    last: Int
    before: String
    after: String
  ): AssigneeConnection!
  auditable: Auditable!
  attachments(
    first: Int
    last: Int
    before: String
    after: String
  ): AttachmentConnection!
  name: DisplayName!
  required: Boolean
  status: ChecklistStatus!
  value: ChecklistResultValue!
}

union ChecklistResultValue = Counter | Flag | Register

## Our checklists go Open > In Progress > Closed
union ChecklistStatus = ChecklistOpen | ChecklistInProgress | ChecklistClosed
type ChecklistOpen implements Component {
  id: Entity!
  openedBy: Actor
  openedAt: Temporal!
}
type ChecklistInProgress implements Component {
  id: Entity!
  inProgressBy: Actor!
  inProgressAt: Temporal!
}
type ChecklistClosed implements Component {
  id: Entity!
  closedBy: Actor!
  closedAt: Temporal!
  closedBecause: ChecklistClosedReason!
}
type ChecklistClosedReason {
  code: ChecklistClosedReasonCode!
  note: DynamicString
}
enum ChecklistClosedReasonCode {
  success
  error
}
