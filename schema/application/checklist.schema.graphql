type Checklist implements Component {
  id: ID!
  assignees(first: Int, last: Int, before: String, after: String): AssigneeConnection!
  attachments: [Attachment!]
  auditable: Auditable!
  description: Description
  items: [ChecklistItem!]!
  name: DisplayName!
  required: Boolean
  schedule: Schedule
  sop: Sop
  status: ChecklistStatus!
}

## We want our checklists to support nesting
union ChecklistItem = Checklist | ChecklistResult
type ChecklistResult implements Component {
  id: ID!
  assignees: [Assignee!]!
  auditable: Auditable!
  attachments: [Attachment!]
  name: DisplayName!
  required: Boolean
  value: String
}

## Our checklists go Open > In Progress > Closed
union ChecklistStatus = ChecklistOpen | ChecklistInProgress | ChecklistClosed
type ChecklistOpen implements Component {
  id: ID!
  openedBy: Worker
  openedAt: Temporal!
}
type ChecklistInProgress implements Component {
  id: ID!
  inProgressBy: Worker!
  inProgressAt: Temporal!
}
type ChecklistClosed implements Component {
  id: ID!
  closedBy: Worker!
  closedAt: Temporal!
  closedBecause: ChecklistClosedReason!
}
type ChecklistClosedReason {
  code: ChecklistClosedReasonCode!
  note: DynamicString
}
enum ChecklistClosedReasonCode {
  success
  error
}

# Next up: Systems (mutations?)
# These will be how we do audits, computed fields, etc...

type Query {
  checklists: [Checklist!]!
}
