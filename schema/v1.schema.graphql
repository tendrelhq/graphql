"""
Indicates that a position is semantically non null: it is only null if there is a matching error in the `errors` array.
In all other cases, the position is non-null.

Tools doing code generation may use this information to generate the position as non-null if field errors are handled out of band:

```graphql
type User {
    # email is semantically non-null and can be generated as non-null by error-handling clients.
    email: String @semanticNonNull
}
```

The `levels` argument indicates what levels are semantically non null in case of lists:

```graphql
type User {
    # friends is semantically non null
    friends: [User] @semanticNonNull # same as @semanticNonNull(levels: [0])

    # every friends[k] is semantically non null
    friends: [User] @semanticNonNull(levels: [1])

    # friends as well as every friends[k] is semantically non null
    friends: [User] @semanticNonNull(levels: [0, 1])
}
```

`levels` are zero indexed.
Passing a negative level or a level greater than the list dimension is an error.
"""
directive @semanticNonNull(levels: [Int] = [0]) on FIELD_DEFINITION

"""
A language tag in the format of a BCP 47 (RFC 5646) standard string.
"""
scalar Locale @specifiedBy(url: "https://www.rfc-editor.org/rfc/rfc5646.html")

union TaskState = Closed | InProgress | Open

"""
Identifies an Entity as being assignable to another Entity.
"""
interface Assignable implements Component {
  id: ID!
}

"""
Components characterize Entities as possessing a particular trait.
They are just simple structs, holding all data necessary to model that trait.
"""
interface Component {
  id: ID!
}

"""
Indicates an object that is "refetchable".
"""
interface Node {
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
}

"""
Identifies an Entity as being "trackable".
What exactly this means depends on the type underlying said entity and is
entirely user defined.
"""
interface Trackable implements Component {
  id: ID!
  """
  Entrypoint into the "tracking system(s)" for a given Entity. Note that while
  many types admit to being trackable, this does not mean that all in fact are
  in practice. In order for an Entity to be trackable, it must be explicitly
  configured as such.
  """
  tracking: TrackableConnection
}

input AssignmentInput {
  assignedTo: ID!
}

input DynamicStringInput {
  locale: Locale!
  value: String!
}

input FieldInput {
  field: ID!
  value: ValueInput
}

input FsmOptions {
  """
  The unique identifier of the FSM on which you are operating. Wherever you
  access the `fsm` field of a `Task`, that task's id should go here.
  """
  fsm: ID!
  """
  [object Object],[object Object],[object Object]
  """
  task: TaskInput!
}

input TaskInput {
  id: ID!
  overrides: [FieldInput!]
}

input TimestampInput {
  epochMilliseconds: String!
  timeZone: String
}

input ValueInput @oneOf {
  boolean: Boolean
  decimal: Float
  """
  Duration in either ISO or millisecond format.
  """
  duration: String
  id: ID
  integer: Int
  string: String
  """
  Timestamp in either ISO or epoch millisecond format.
  """
  timestamp: String
}

"""
Encapsulates the "who" and "when" associated with the act of "assignment".
For example, both Tasks and Workers implement Assignable and therefore a Task
can be assigned to a Worker and vice versa ("assignment" is commutative). In
this example, the "who" will always be the Worker and the "when" will be the
timestamp when these two Entities were assigned.
"""
type Assignment implements Node {
  """
  NOT YET IMPLEMENTED - will always return null!
  """
  assignedAt: TimestampOverridable
  assignedTo: Assignable
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
}

type AssignmentConnection {
  edges: [AssignmentEdge!] @semanticNonNull
  pageInfo: PageInfo @semanticNonNull
  totalCount: Int @semanticNonNull
}

type AssignmentEdge {
  cursor: String @semanticNonNull
  node: Assignment @semanticNonNull
}

type Closed {
  closedAt: TimestampOverridable @semanticNonNull
  closedBecause: String
  closedBy: String
  inProgressAt: TimestampOverridable
  inProgressBy: String
  openedAt: TimestampOverridable @semanticNonNull
  openedBy: String
}

type DisplayName implements Component & Node {
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
  name: DynamicString @semanticNonNull
}

"""
Plain text content that has been (potentially) translated into different
languages as specified by the user's configuration.
"""
type DynamicString {
  locale: Locale @semanticNonNull
  value: String @semanticNonNull
}

type InProgress {
  inProgressAt: TimestampOverridable @semanticNonNull
  inProgressBy: String
  openedAt: TimestampOverridable @semanticNonNull
  openedBy: String
}

type Location implements Component & Node & Trackable {
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
  """
  Entrypoint into the "tracking system(s)" for the given Location.
  """
  tracking: TrackableConnection
}

type Mutation {
  advance(opts: FsmOptions!): Task @semanticNonNull
}

type Open {
  openedAt: TimestampOverridable @semanticNonNull
  openedBy: String
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean @semanticNonNull
  hasPreviousPage: Boolean @semanticNonNull
  startCursor: String
}

type Query {
  node(id: ID!): Node!
  """
  Query for Trackable entities in the given `parent` hierarchy.
  """
  trackables(
    """
    Identifies the root of the hierarchy in which to search for Trackable
    entities.

    Valid parent types are currently:
    - Customer

    All other parent types will be gracefully ignored.
    """
    parent: ID!
  ): TrackableConnection @semanticNonNull
}

"""
A system-level component that identifies an Entity as being applicable to
tendrel's internal "task processing pipeline". In practice, Tasks most often
represent "jobs" performed by humans. However, this need not always be the
case.

Technically speaking, a Task represents a (1) *named asynchronous process*
that (2) exists in one of three states: open, in progress, or closed.
"""
type Task implements Assignable & Component & Node & Trackable {
  """
  [object Object],[object Object],[object Object]
  """
  assignees: AssignmentConnection
  displayName: DisplayName @semanticNonNull
  """
  Tasks can have an associated StateMachine, which defines a finite set of
  states that the given Task can be in at any given time.
  """
  fsm: TaskStateMachine
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
  state: TaskState
  """
  Entrypoint into the "tracking system(s)" for the given Task.
  At the moment, sub-task tracking is not supported and therefore `null` will
  always be returned for this field.
  """
  tracking: TrackableConnection
}

type TaskConnection {
  edges: [TaskEdge!] @semanticNonNull
  pageInfo: PageInfo @semanticNonNull
  totalCount: Int @semanticNonNull
}

type TaskEdge {
  cursor: String @semanticNonNull
  node: Task @semanticNonNull
}

"""
Where applicable, Entities can have an associated StateMachine that defines
their current ("active") state in addition to possible next states that they
can "transition into". Typically, an end user does not need to be aware of
this state machine as Tendrel's internal engine maintains the machine and
associated states for a given Entity. However, in some cases it can be useful
to surface this information in userland such that a user can interact
directly with the underlying state machine.
"""
type TaskStateMachine {
  active: Task
  transitions: TaskConnection
}

type Timestamp {
  epochMilliseconds: String @semanticNonNull
  timeZone: String @semanticNonNull
}

type TimestampOverridable {
  override: TimestampOverride
  value: Timestamp @semanticNonNull
}

type TimestampOverride {
  overriddenAt: String
  overriddenBy: String
  previousValue: Timestamp @semanticNonNull
}

type TrackableConnection {
  edges: [TrackableEdge!] @semanticNonNull
  pageInfo: PageInfo @semanticNonNull
  totalCount: Int @semanticNonNull
}

type TrackableEdge {
  cursor: String @semanticNonNull
  node: Trackable @semanticNonNull
}
