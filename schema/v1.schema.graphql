"""
Indicates that a position is semantically non null: it is only null if there is a matching error in the `errors` array.
In all other cases, the position is non-null.

Tools doing code generation may use this information to generate the position as non-null if field errors are handled out of band:

```graphql
type User {
    # email is semantically non-null and can be generated as non-null by error-handling clients.
    email: String @semanticNonNull
}
```

The `levels` argument indicates what levels are semantically non null in case of lists:

```graphql
type User {
    # friends is semantically non null
    friends: [User] @semanticNonNull # same as @semanticNonNull(levels: [0])

    # every friends[k] is semantically non null
    friends: [User] @semanticNonNull(levels: [1])

    # friends as well as every friends[k] is semantically non null
    friends: [User] @semanticNonNull(levels: [0, 1])
}
```

`levels` are zero indexed.
Passing a negative level or a level greater than the list dimension is an error.
"""
directive @semanticNonNull(levels: [Int] = [0]) on FIELD_DEFINITION

"""
A language tag in the format of a BCP 47 (RFC 5646) standard string.
"""
scalar Locale @specifiedBy(url: "https://www.rfc-editor.org/rfc/rfc5646.html")

union TaskState = Closed | InProgress | Open

"""
Components characterize Entities as possessing a particular trait.
They are just simple structs, holding all data necessary to model that trait.
"""
interface Component {
  id: ID!
}

"""
Indicates an object that is "refetchable".
"""
interface Node {
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
}

"""
Identifies an Entity as being "trackable".
What exactly this means depends on the type underlying said entity and is
entirely user defined.
"""
interface Trackable implements Component {
  id: ID!
  """
  Entrypoint into the "tracking system(s)" for a given Entity. Note that while
  many types admit to being trackable, this does not mean that all in fact are
  in practice. In order for an Entity to be trackable, it must be explicitly
  configured as such.
  """
  tracking: TrackableConnection
}

input DynamicStringInput {
  locale: Locale!
  value: String!
}

type Closed {
  closedAt: String @semanticNonNull
  closedBecause: String
  closedBy: String
  dueAt: String
  inProgressAt: String
  inProgressBy: String
  openedAt: String @semanticNonNull
  openedBy: String
}

type DisplayName implements Component & Node {
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
  name: DynamicString @semanticNonNull
}

"""
Plain text content that has been (potentially) translated into different
languages as specified by the user's configuration.
"""
type DynamicString {
  locale: Locale @semanticNonNull
  value: String @semanticNonNull
}

type InProgress {
  dueAt: String
  inProgressAt: String @semanticNonNull
  inProgressBy: String
  openedAt: String @semanticNonNull
  openedBy: String
}

type Location implements Component & Node & Trackable {
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
  """
  Entrypoint into the "tracking system(s)" for the given Location.
  """
  tracking: TrackableConnection
}

type Mutation {
  advance(
    """
    The unique identifier of the FSM on which you are operating. Wherever you
    access the `fsm` field of a `Task`, that task's id should go here.
    """
    fsm: ID!
    """
    The unique identifier of a `Task` _within_ the aforementioned FSM. These
    are the tasks available as the `active` and/or `transitions` fields within
    a task's `fsm` field. Advancing a FSM by way of this argument works as
    follows:
    - if the given `task` is Open, move it to In Progress and make it the
      active task in the given `fsm`.
    - if the given `task` is In Progress, move it to Closed and transition the
      overall `fsm` as determined by the rules that define it. Note that there
      are by default no "on close" rules, and thus the result of this operation
      is effectively to revert the `fsm` to the state it was in _prior to_
      advancing into its current state. Note that this might imply putting the
      `fsm` back into its initial (typically "idle") state.
    - if the given `task` is Closed, this operation is a no-op.
    """
    task: ID!
  ): Task @semanticNonNull
  """
  Start the given Task, identified by the `task` argument.
  Optionally, a `parent` argument may also be provided to this function. The
  purpose of this argument is to avoid necessitating *two* network calls where
  the first is this mutation and the second would be another query to refetch
  data only transitively related to this Task.
  """
  startTask(parent: ID, task: ID!): TaskActionResult @semanticNonNull
  stopTask(parent: ID, task: ID!): TaskActionResult @semanticNonNull
}

type Open {
  dueAt: String
  openedAt: TimestampOverridable @semanticNonNull
  openedBy: String
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean @semanticNonNull
  hasPreviousPage: Boolean @semanticNonNull
  startCursor: String
}

type Query {
  node(id: ID!): Node!
  """
  Query for Trackable entities in the given `parent` hierarchy.
  """
  trackables(
    """
    Identifies the root of the hierarchy in which to search for Trackable
    entities.

    Valid parent types are currently:
    - Customer

    All other parent types will be gracefully ignored.
    """
    parent: ID!
  ): TrackableConnection @semanticNonNull
}

"""
A system-level component that identifies an Entity as being applicable to
tendrel's internal "task processing pipeline". In practice, Tasks most often
represent "jobs" performed by humans. However, this need not always be the
case.

Technically speaking, a Task represents a (1) *named asynchronous process*
that (2) exists in one of three states: open, in progress, or closed.
"""
type Task implements Component & Node & Trackable {
  displayName: DisplayName @semanticNonNull
  """
  Tasks can have an associated StateMachine, which defines a finite set of
  states that the given Task can be in at any given time.
  """
  fsm: TaskStateMachine
  """
  A globally unique opaque identifier for a node.
  """
  id: ID!
  state: TaskState @semanticNonNull
  """
  Entrypoint into the "tracking system(s)" for the given Task.
  At the moment, sub-task tracking is not supported and therefore `null` will
  always be returned for this field.
  """
  tracking: TrackableConnection
}

type TaskActionResult {
  parent: Node
  task: Task @semanticNonNull
}

type TaskConnection {
  edges: [TaskEdge!] @semanticNonNull
  pageInfo: PageInfo @semanticNonNull
  totalCount: Int @semanticNonNull
}

type TaskEdge {
  cursor: String @semanticNonNull
  node: Task @semanticNonNull
}

"""
Where applicable, Entities can have an associated StateMachine that defines
their current ("active") state in addition to possible next states that they
can "transition into". Typically, an end user does not need to be aware of
this state machine as Tendrel's internal engine maintains the machine and
associated states for a given Entity. However, in some cases it can be useful
to surface this information in userland such that a user can interact
directly with the underlying state machine.
"""
type TaskStateMachine {
  active: Task
  transitions: TaskConnection
}

type Timestamp {
  value: String @semanticNonNull
}

type TimestampOverridable {
  override: TimestampOverride
  value: Timestamp @semanticNonNull
}

type TimestampOverride {
  overriddenAt: String @semanticNonNull
  overriddenBy: String @semanticNonNull
  previousValue: Timestamp @semanticNonNull
}

type TrackableConnection {
  edges: [TrackableEdge!] @semanticNonNull
  pageInfo: PageInfo @semanticNonNull
  totalCount: Int @semanticNonNull
}

type TrackableEdge {
  cursor: String @semanticNonNull
  node: Trackable @semanticNonNull
}
